{
  "language": "Solidity",
  "sources": {
    "contracts/deploy/NanoUniversalDeployer.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity ^0.8.8;\r\n\r\ncontract NanoUniversalDeployer {\r\n    event Deploy(address _addr) anonymous;\r\n\r\n    fallback() external payable {\r\n        address addr;\r\n        bytes memory code = msg.data;\r\n        assembly {\r\n            addr := create2(callvalue(), add(code, 32), mload(code), 0)\r\n        }\r\n        emit Deploy(addr);\r\n    }\r\n}\r\n"
    },
    "contracts/dxvote/WalletScheme.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity ^0.8.8;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"../utils/PermissionRegistry.sol\";\r\n\r\n/**\r\n * @title WalletScheme.\r\n * @dev  A scheme for proposing and executing calls to any contract except itself\r\n * It has a value call controller address, in case of the controller address ot be set the scheme will be doing\r\n * generic calls to the dao controller. If the controller address is not set it will e executing raw calls form the\r\n * scheme itself.\r\n * The scheme can only execute calls allowed to in the permission registry, if the controller address is set\r\n * the permissions will be checked using the avatar address as sender, if not the scheme address will be used as\r\n * sender.\r\n */\r\ncontract WalletScheme {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    string public constant SCHEME_TYPE = \"Wallet Scheme v1.3\";\r\n    bytes4 public constant ERC20_TRANSFER_SIGNATURE = bytes4(keccak256(\"transfer(address,uint256)\"));\r\n    bytes4 public constant ERC20_APPROVE_SIGNATURE = bytes4(keccak256(\"approve(address,uint256)\"));\r\n    bytes4 public constant SET_MAX_SECONDS_FOR_EXECUTION_SIGNATURE =\r\n        bytes4(keccak256(\"setMaxSecondsForExecution(uint256)\"));\r\n\r\n    enum ProposalState {\r\n        None,\r\n        Submitted,\r\n        Rejected,\r\n        ExecutionSucceeded,\r\n        ExecutionTimeout\r\n    }\r\n\r\n    struct Proposal {\r\n        address[] to;\r\n        bytes[] callData;\r\n        uint256[] value;\r\n        ProposalState state;\r\n        string title;\r\n        string descriptionHash;\r\n        uint256 submittedTime;\r\n    }\r\n\r\n    mapping(bytes32 => Proposal) public proposals;\r\n    bytes32[] public proposalsList;\r\n\r\n    bool public doAvatarGenericCalls;\r\n    address public controller;\r\n    PermissionRegistry public permissionRegistry;\r\n    string public schemeName;\r\n    uint256 public maxSecondsForExecution;\r\n    uint256 public maxRepPercentageChange;\r\n\r\n    address public votingMachine;\r\n    address public avatar;\r\n\r\n    // Boolean that is true when is executing a proposal, to avoid re-entrancy attacks.\r\n    bool internal executingProposal;\r\n\r\n    event ProposalStateChange(bytes32 indexed _proposalId, uint256 indexed _state);\r\n    event ExecutionResults(bytes32 indexed _proposalId, bool[] _callsSucessResult, bytes[] _callsDataResult);\r\n\r\n    /**\r\n     * @dev initialize\r\n     * @param _avatar the avatar address\r\n     * @param _votingMachine the voting machine address\r\n     * @param _doAvatarGenericCalls will the scheme do generic calls from the avatar\r\n     * @param _controller The controller address\r\n     * @param _permissionRegistry The address of the permission registry contract\r\n     * @param _maxSecondsForExecution The maximum amount of time in seconds for a proposal without executed since\r\n     * submitted time\r\n     * @param _maxRepPercentageChange The maximum percentage allowed to be changed in REP total supply after proposal\r\n     * execution\r\n     */\r\n    function initialize(\r\n        address _avatar,\r\n        address _votingMachine,\r\n        bool _doAvatarGenericCalls,\r\n        address _controller,\r\n        address _permissionRegistry,\r\n        string calldata _schemeName,\r\n        uint256 _maxSecondsForExecution,\r\n        uint256 _maxRepPercentageChange\r\n    ) external {\r\n        require(avatar == address(0), \"WalletScheme: cannot init twice\");\r\n        require(_avatar != address(0), \"WalletScheme: avatar cannot be zero\");\r\n        require(_controller != address(0), \"WalletScheme: controller cannot be zero\");\r\n        require(\r\n            _maxSecondsForExecution >= 86400,\r\n            \"WalletScheme: _maxSecondsForExecution cant be less than 86400 seconds\"\r\n        );\r\n        avatar = _avatar;\r\n        votingMachine = _votingMachine;\r\n        doAvatarGenericCalls = _doAvatarGenericCalls;\r\n        controller = _controller;\r\n        permissionRegistry = PermissionRegistry(_permissionRegistry);\r\n        schemeName = _schemeName;\r\n        maxSecondsForExecution = _maxSecondsForExecution;\r\n        maxRepPercentageChange = _maxRepPercentageChange;\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function that allows the wallet to receive ETH when the controller address is not set\r\n     */\r\n    receive() external payable {\r\n        require(!doAvatarGenericCalls, \"WalletScheme: Cant receive if it will make generic calls to avatar\");\r\n    }\r\n\r\n    /**\r\n     * @dev Set the max amount of seconds that a proposal has to be executed, only callable from the avatar address\r\n     * @param _maxSecondsForExecution New max proposal time in seconds to be used\r\n     */\r\n    function setMaxSecondsForExecution(uint256 _maxSecondsForExecution) external {\r\n        require(\r\n            msg.sender == address(avatar),\r\n            \"WalletScheme: setMaxSecondsForExecution is callable only form the avatar\"\r\n        );\r\n        require(\r\n            _maxSecondsForExecution >= 86400,\r\n            \"WalletScheme: _maxSecondsForExecution cant be less than 86400 seconds\"\r\n        );\r\n        maxSecondsForExecution = _maxSecondsForExecution;\r\n    }\r\n\r\n    /**\r\n     * @dev execution of proposals, can only be called by the voting machine in which the vote is held.\r\n        REQUIRE FROM \"../daostack/votingMachines/ProposalExecuteInterface.sol\" DONT REMOVE\r\n     * @param _proposalId the ID of the voting in the voting machine\r\n     * @param _decision a parameter of the voting result, 1 yes and 2 is no.\r\n     * @return bool success\r\n     */\r\n    function executeProposal(bytes32 _proposalId, int256 _decision) external onlyVotingMachine returns (bool) {\r\n        require(!executingProposal, \"WalletScheme: proposal execution already running\");\r\n        executingProposal = true;\r\n\r\n        Proposal storage proposal = proposals[_proposalId];\r\n        require(proposal.state == ProposalState.Submitted, \"WalletScheme: must be a submitted proposal\");\r\n\r\n        // If the amount of time passed since submission plus max proposal time is lower than block timestamp\r\n        // the proposal timeout execution is reached and proposal cant be executed from now on\r\n        if (proposal.submittedTime.add(maxSecondsForExecution) < block.timestamp) {\r\n            proposal.state = ProposalState.ExecutionTimeout;\r\n            emit ProposalStateChange(_proposalId, uint256(ProposalState.ExecutionTimeout));\r\n\r\n            // If decision is 1, it means the proposal was approved by the voting machine\r\n        } else if (_decision == 1) {\r\n            uint256 oldRepSupply = getNativeReputationTotalSupply();\r\n\r\n            // If one call fails the transaction will revert\r\n            bytes[] memory callsDataResult = new bytes[](proposal.to.length);\r\n            bool[] memory callsSucessResult = new bool[](proposal.to.length);\r\n            address _asset;\r\n            address _to;\r\n            bytes4 _callDataFuncSignature;\r\n            uint256 _value;\r\n\r\n            if (doAvatarGenericCalls) {\r\n                address(controller).call(\r\n                    abi.encodeWithSignature(\r\n                        \"genericCall(address,bytes,address,uint256)\",\r\n                        address(permissionRegistry),\r\n                        abi.encodeWithSignature(\"setERC20Balances()\"),\r\n                        avatar,\r\n                        0\r\n                    )\r\n                );\r\n            } else {\r\n                permissionRegistry.setERC20Balances();\r\n            }\r\n\r\n            for (uint256 i = 0; i < proposal.to.length; i++) {\r\n                _asset = address(0);\r\n                _callDataFuncSignature = this.getFuncSignature(proposal.callData[i]);\r\n\r\n                // The permission registry keeps track of all value transferred and checks call permission\r\n                if (doAvatarGenericCalls) {\r\n                    (, bytes memory permissionData) = address(controller).call(\r\n                        abi.encodeWithSignature(\r\n                            \"genericCall(address,bytes,address,uint256)\",\r\n                            address(permissionRegistry),\r\n                            abi.encodeWithSignature(\r\n                                \"setETHPermissionUsed(address,address,bytes4,uint256)\",\r\n                                avatar,\r\n                                proposal.to[i],\r\n                                _callDataFuncSignature,\r\n                                proposal.value[i]\r\n                            ),\r\n                            avatar,\r\n                            0\r\n                        )\r\n                    );\r\n                    // if permissionData is longer than 96 bytes this is cause it is a revert message\r\n                    require(permissionData.length == 96, \"WalletScheme: permission check failed\");\r\n                } else {\r\n                    permissionRegistry.setETHPermissionUsed(\r\n                        address(this),\r\n                        proposal.to[i],\r\n                        _callDataFuncSignature,\r\n                        proposal.value[i]\r\n                    );\r\n                }\r\n\r\n                // If controller address is set the code needs to be encoded to genericCall function\r\n                if (doAvatarGenericCalls && proposal.to[i] != address(controller)) {\r\n                    bytes memory genericCallData = abi.encodeWithSignature(\r\n                        \"genericCall(address,bytes,address,uint256)\",\r\n                        proposal.to[i],\r\n                        proposal.callData[i],\r\n                        avatar,\r\n                        proposal.value[i]\r\n                    );\r\n                    (callsSucessResult[i], callsDataResult[i]) = address(controller).call{value: 0}(genericCallData);\r\n\r\n                    // The success is form the generic call, but the result data is from the call to the controller\r\n                    (bool genericCallSucessResult, ) = abi.decode(callsDataResult[i], (bool, bytes));\r\n                    callsSucessResult[i] = genericCallSucessResult;\r\n\r\n                    // If controller address is not set the call is made to\r\n                } else {\r\n                    (callsSucessResult[i], callsDataResult[i]) = address(proposal.to[i]).call{value: proposal.value[i]}(\r\n                        proposal.callData[i]\r\n                    );\r\n                }\r\n\r\n                // If the call reverted the entire execution will revert\r\n                require(callsSucessResult[i], \"WalletScheme: call execution failed\");\r\n            }\r\n            // Cant mint or burn more REP than the allowed percentaged set in the wallet scheme initialization\r\n            require(\r\n                (oldRepSupply.mul(uint256(100).add(maxRepPercentageChange)).div(100) >=\r\n                    getNativeReputationTotalSupply()) &&\r\n                    (oldRepSupply.mul(uint256(100).sub(maxRepPercentageChange)).div(100) <=\r\n                        getNativeReputationTotalSupply()),\r\n                \"WalletScheme: maxRepPercentageChange passed\"\r\n            );\r\n\r\n            require(permissionRegistry.checkERC20Limits(doAvatarGenericCalls ? avatar : address(this)));\r\n\r\n            proposal.state = ProposalState.ExecutionSucceeded;\r\n            emit ProposalStateChange(_proposalId, uint256(ProposalState.ExecutionSucceeded));\r\n            emit ExecutionResults(_proposalId, callsSucessResult, callsDataResult);\r\n\r\n            // If decision is 2, it means the proposal was rejected by the voting machine\r\n        } else {\r\n            proposal.state = ProposalState.Rejected;\r\n            emit ProposalStateChange(_proposalId, uint256(ProposalState.Rejected));\r\n        }\r\n\r\n        executingProposal = false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Propose calls to be executed, the calls have to be allowed by the permission registry\r\n     * @param _to - The addresses to call\r\n     * @param _callData - The abi encode data for the calls\r\n     * @param _value value(ETH) to transfer with the calls\r\n     * @param _title title of proposal\r\n     * @param _descriptionHash proposal description hash\r\n     * @return an id which represents the proposal\r\n     */\r\n    function proposeCalls(\r\n        address[] calldata _to,\r\n        bytes[] calldata _callData,\r\n        uint256[] calldata _value,\r\n        string calldata _title,\r\n        string calldata _descriptionHash\r\n    ) external returns (bytes32) {\r\n        // Check the proposal calls\r\n        for (uint256 i = 0; i < _to.length; i++) {\r\n            bytes4 callDataFuncSignature = getFuncSignature(_callData[i]);\r\n\r\n            // Only allow proposing calls to this address to call setMaxSecondsForExecution function\r\n            require(\r\n                _to[i] != address(this) ||\r\n                    (callDataFuncSignature == SET_MAX_SECONDS_FOR_EXECUTION_SIGNATURE && _value[i] == 0),\r\n                \"WalletScheme: invalid proposal caller\"\r\n            );\r\n\r\n            // This will fail only when and ERC20 transfer or approve with ETH value is proposed\r\n            require(\r\n                (callDataFuncSignature != ERC20_TRANSFER_SIGNATURE &&\r\n                    callDataFuncSignature != ERC20_APPROVE_SIGNATURE) || _value[i] == 0,\r\n                \"WalletScheme: cant propose ERC20 transfers with value\"\r\n            );\r\n        }\r\n        require(_to.length == _callData.length, \"WalletScheme: invalid _callData length\");\r\n        require(_to.length == _value.length, \"WalletScheme: invalid _value length\");\r\n\r\n        bytes32 voteParams = abi.decode(\r\n            controller.functionStaticCall(\r\n                abi.encodeWithSignature(\"getSchemeParameters(address,address)\", address(this), avatar),\r\n                \"WalletScheme: getSchemeParameters error\"\r\n            ),\r\n            (bytes32)\r\n        );\r\n\r\n        // Get the proposal id that will be used from the voting machine\r\n        // bytes32 proposalId = votingMachine.propose(2, voteParams, msg.sender, address(avatar));\r\n        bytes32 proposalId = abi.decode(\r\n            votingMachine.functionCall(\r\n                abi.encodeWithSignature(\"propose(uint256,bytes32,address,address)\", 2, voteParams, msg.sender, avatar),\r\n                \"WalletScheme: DXDVotingMachine callback propose error\"\r\n            ),\r\n            (bytes32)\r\n        );\r\n\r\n        // Add the proposal to the proposals mapping, proposals list and proposals information mapping\r\n        proposals[proposalId] = Proposal({\r\n            to: _to,\r\n            callData: _callData,\r\n            value: _value,\r\n            state: ProposalState.Submitted,\r\n            title: _title,\r\n            descriptionHash: _descriptionHash,\r\n            submittedTime: block.timestamp\r\n        });\r\n        // slither-disable-next-line all\r\n        proposalsList.push(proposalId);\r\n        proposalsBlockNumber[proposalId] = block.number;\r\n        emit ProposalStateChange(proposalId, uint256(ProposalState.Submitted));\r\n        return proposalId;\r\n    }\r\n\r\n    /**\r\n     * @dev Get the information of a proposal by id\r\n     * @param proposalId the ID of the proposal\r\n     */\r\n    function getOrganizationProposal(bytes32 proposalId)\r\n        public\r\n        view\r\n        returns (\r\n            address[] memory to,\r\n            bytes[] memory callData,\r\n            uint256[] memory value,\r\n            ProposalState state,\r\n            string memory title,\r\n            string memory descriptionHash,\r\n            uint256 submittedTime\r\n        )\r\n    {\r\n        return (\r\n            proposals[proposalId].to,\r\n            proposals[proposalId].callData,\r\n            proposals[proposalId].value,\r\n            proposals[proposalId].state,\r\n            proposals[proposalId].title,\r\n            proposals[proposalId].descriptionHash,\r\n            proposals[proposalId].submittedTime\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Get the information of a proposal by index\r\n     * @param proposalIndex the index of the proposal in the proposals list\r\n     */\r\n    function getOrganizationProposalByIndex(uint256 proposalIndex)\r\n        external\r\n        view\r\n        returns (\r\n            address[] memory to,\r\n            bytes[] memory callData,\r\n            uint256[] memory value,\r\n            ProposalState state,\r\n            string memory title,\r\n            string memory descriptionHash,\r\n            uint256 submittedTime\r\n        )\r\n    {\r\n        return getOrganizationProposal(proposalsList[proposalIndex]);\r\n    }\r\n\r\n    /**\r\n     * @dev Get call data signature\r\n     * @param data The bytes data of the data to get the signature\r\n     */\r\n    function getFuncSignature(bytes calldata data) public pure returns (bytes4) {\r\n        if (data.length >= 4) {\r\n            return bytes4(data[:4]);\r\n        } else {\r\n            return bytes4(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get the proposals length\r\n     */\r\n    function getOrganizationProposalsLength() external view returns (uint256) {\r\n        return proposalsList.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Get the proposals ids\r\n     */\r\n    function getOrganizationProposals() external view returns (bytes32[] memory) {\r\n        return proposalsList;\r\n    }\r\n\r\n    /**\r\n     * @dev DXDVotingMachineCallbacks DONT REMOVE\r\n     */\r\n\r\n    modifier onlyVotingMachine() {\r\n        require(msg.sender == address(votingMachine), \"only VotingMachine\");\r\n        _;\r\n    }\r\n\r\n    mapping(bytes32 => uint256) public proposalsBlockNumber;\r\n\r\n    function mintReputation(\r\n        uint256 _amount,\r\n        address _beneficiary,\r\n        bytes32\r\n    ) external onlyVotingMachine returns (bool) {\r\n        // return ControllerInterface(avatar.owner()).mintReputation(_amount, _beneficiary, address(avatar));\r\n        return\r\n            abi.decode(\r\n                controller.functionCall(\r\n                    abi.encodeWithSignature(\r\n                        \"mintReputation(uint256,address,address)\",\r\n                        _amount,\r\n                        _beneficiary,\r\n                        address(avatar)\r\n                    ),\r\n                    \"WalletScheme: DXDVotingMachine callback mintReputation error\"\r\n                ),\r\n                (bool)\r\n            );\r\n    }\r\n\r\n    function burnReputation(\r\n        uint256 _amount,\r\n        address _beneficiary,\r\n        bytes32\r\n    ) external onlyVotingMachine returns (bool) {\r\n        // return ControllerInterface(avatar.owner()).burnReputation(_amount, _beneficiary, address(avatar));\r\n        return\r\n            abi.decode(\r\n                controller.functionCall(\r\n                    abi.encodeWithSignature(\r\n                        \"burnReputation(uint256,address,address)\",\r\n                        _amount,\r\n                        _beneficiary,\r\n                        address(avatar)\r\n                    ),\r\n                    \"WalletScheme: DXDVotingMachine callback burnReputation error\"\r\n                ),\r\n                (bool)\r\n            );\r\n    }\r\n\r\n    function stakingTokenTransfer(\r\n        IERC20 _stakingToken,\r\n        address _beneficiary,\r\n        uint256 _amount,\r\n        bytes32\r\n    ) external onlyVotingMachine returns (bool) {\r\n        return\r\n            abi.decode(\r\n                controller.functionCall(\r\n                    abi.encodeWithSignature(\r\n                        \"externalTokenTransfer(address,address,uint256,address)\",\r\n                        address(_stakingToken),\r\n                        _beneficiary,\r\n                        _amount,\r\n                        address(avatar)\r\n                    ),\r\n                    \"WalletScheme: DXDVotingMachine callback externalTokenTransfer error\"\r\n                ),\r\n                (bool)\r\n            );\r\n    }\r\n\r\n    function getNativeReputation() public view returns (address) {\r\n        // return Avatar(avatar).nativeReputation();\r\n        return\r\n            abi.decode(\r\n                avatar.functionStaticCall(\r\n                    abi.encodeWithSignature(\"nativeReputation()\"),\r\n                    \"WalletScheme: DXDVotingMachine callback nativeReputation error\"\r\n                ),\r\n                (address)\r\n            );\r\n    }\r\n\r\n    function getNativeReputationTotalSupply() public view returns (uint256) {\r\n        // return Avatar(avatar).nativeReputation().totalSupply();\r\n        return\r\n            abi.decode(\r\n                getNativeReputation().functionStaticCall(\r\n                    abi.encodeWithSignature(\"totalSupply()\"),\r\n                    \"WalletScheme: DXDVotingMachine callback totalSupply error\"\r\n                ),\r\n                (uint256)\r\n            );\r\n    }\r\n\r\n    function balanceOfStakingToken(IERC20 _stakingToken, bytes32) external view returns (uint256) {\r\n        return _stakingToken.balanceOf(address(avatar));\r\n    }\r\n\r\n    function getTotalReputationSupply(bytes32 _proposalId) external view returns (uint256) {\r\n        // return Avatar(avatar).nativeReputation().totalSupplyAt(proposalsBlockNumber[_proposalId]);\r\n        return\r\n            abi.decode(\r\n                getNativeReputation().functionStaticCall(\r\n                    abi.encodeWithSignature(\"totalSupplyAt(uint256)\", proposalsBlockNumber[_proposalId]),\r\n                    \"WalletScheme: DXDVotingMachine callback totalSupplyAt error\"\r\n                ),\r\n                (uint256)\r\n            );\r\n    }\r\n\r\n    function reputationOf(address _owner, bytes32 _proposalId) external view returns (uint256) {\r\n        // return Avatar(avatar).nativeReputation().balanceOfAt(_owner, proposalsBlockNumber[_proposalId]);\r\n        return\r\n            abi.decode(\r\n                getNativeReputation().functionStaticCall(\r\n                    abi.encodeWithSignature(\"balanceOfAt(address,uint256)\", _owner, proposalsBlockNumber[_proposalId]),\r\n                    \"WalletScheme: DXDVotingMachine callback balanceOfAt error\"\r\n                ),\r\n                (uint256)\r\n            );\r\n    }\r\n}\r\n"
    },
    "contracts/utils/PermissionRegistry.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity ^0.8.8;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/**\r\n * @title PermissionRegistry.\r\n * @dev A registry of smart contracts functions and ERC20 transfer limits that are allowed to be called between contracts.\r\n * A time delay in seconds over the permissions can be set form any contract, this delay would be added to any new\r\n * permissions sent by that address.\r\n * The PermissionRegistry owner (if there is an owner and owner address is not 0x0) can overwrite/set any permission.\r\n * The registry allows setting ERC20 limits, the limit needs to be set at the beggining of the block and then it can be\r\n * checked at any time. To remove or replace ERC20 limits first it needs to be removed and then it can be set again.\r\n * The smart contracts permissions are compound by the `from` address, `to` address, `value` uint256 and `fromTime` uint256,\r\n * if `fromTime` is zero it means the function is not allowed.\r\n */\r\n\r\ncontract PermissionRegistry is OwnableUpgradeable {\r\n    using SafeMathUpgradeable for uint256;\r\n\r\n    mapping(address => uint256) public permissionDelay;\r\n\r\n    event PermissionSet(address from, address to, bytes4 functionSignature, uint256 fromTime, uint256 value);\r\n\r\n    struct ETHPermission {\r\n        uint256 valueTransferred;\r\n        uint256 valueTransferedOnBlock;\r\n        uint256 valueAllowed;\r\n        uint256 fromTime;\r\n    }\r\n\r\n    struct ERC20Limit {\r\n        address token;\r\n        uint256 initialValueOnBlock;\r\n        uint256 valueAllowed;\r\n        uint256 removeTime;\r\n    }\r\n\r\n    // from address => to address => function call signature allowed => Permission\r\n    mapping(address => mapping(address => mapping(bytes4 => ETHPermission))) public ethPermissions;\r\n\r\n    // from address => array of tokens allowed and the max value ot be transferred per block\r\n    mapping(address => ERC20Limit[]) erc20Limits;\r\n\r\n    // mapping of the last block number used for the initial balance\r\n    mapping(address => uint256) erc20LimitsOnBlock;\r\n\r\n    /**\r\n     * @dev initializer\r\n     */\r\n    function initialize() public initializer {\r\n        __Ownable_init();\r\n    }\r\n\r\n    /**\r\n     * @dev Set the time delay for a call to show as allowed\r\n     * @param _timeDelay The amount of time that has to pass after permission addition to allow execution\r\n     */\r\n    function setETHPermissionDelay(address from, uint256 _timeDelay) public {\r\n        if (msg.sender != owner()) {\r\n            require(from == msg.sender, \"PermissionRegistry: Only owner can specify from value\");\r\n        }\r\n        permissionDelay[from] = _timeDelay;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the time from which the function can be executed from a contract to another a with which value.\r\n     * @param from The address that will execute the call\r\n     * @param to The address that will be called\r\n     * @param functionSignature The signature of the function to be executed\r\n     * @param valueAllowed The amount of value allowed of the token to be sent\r\n     * @param allowed If the function is allowed or not.\r\n     */\r\n    function setETHPermission(\r\n        address from,\r\n        address to,\r\n        bytes4 functionSignature,\r\n        uint256 valueAllowed,\r\n        bool allowed\r\n    ) public {\r\n        if (msg.sender != owner()) {\r\n            require(from == msg.sender, \"PermissionRegistry: Only owner can specify from value\");\r\n        }\r\n        require(to != address(this), \"PermissionRegistry: Cant set ethPermissions to PermissionRegistry\");\r\n        if (allowed) {\r\n            ethPermissions[from][to][functionSignature].fromTime = block.timestamp.add(permissionDelay[from]);\r\n            ethPermissions[from][to][functionSignature].valueAllowed = valueAllowed;\r\n        } else {\r\n            ethPermissions[from][to][functionSignature].fromTime = 0;\r\n            ethPermissions[from][to][functionSignature].valueAllowed = 0;\r\n        }\r\n        emit PermissionSet(\r\n            from,\r\n            to,\r\n            functionSignature,\r\n            ethPermissions[from][to][functionSignature].fromTime,\r\n            ethPermissions[from][to][functionSignature].valueAllowed\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Add an ERC20Limit for an address, there cannot be more than one limit per token.\r\n     * @param from The address that will execute the call\r\n     * @param token The erc20 token to set the limit\r\n     * @param valueAllowed The amount of value allowed of the token to be sent\r\n     * @param index The index of the token permission in the erco limits\r\n     */\r\n    function addERC20Limit(\r\n        address from,\r\n        address token,\r\n        uint256 valueAllowed,\r\n        uint256 index\r\n    ) public {\r\n        if (msg.sender != owner()) {\r\n            require(from == msg.sender, \"PermissionRegistry: Only owner can specify from value\");\r\n        }\r\n        require(index <= erc20Limits[from].length, \"PermissionRegistry: Index out of bounds\");\r\n        require(token != address(0), \"PermissionRegistry: Token address cannot be 0x0\");\r\n\r\n        uint256 balanceNow = IERC20(token).balanceOf(msg.sender);\r\n\r\n        // set 0 as initialvalue to not allow any balance change for this token on this block\r\n        if (index == erc20Limits[from].length) {\r\n            for (uint256 i = 0; i < erc20Limits[from].length; i++) {\r\n                require(erc20Limits[from][i].token != token, \"PermissionRegistry: Limit on token already added\");\r\n            }\r\n            erc20Limits[from].push(ERC20Limit(token, balanceNow, valueAllowed, 0));\r\n        } else {\r\n            require(\r\n                erc20Limits[from][index].token == address(0),\r\n                \"PermissionRegistry: Cant override existent ERC20 limit\"\r\n            );\r\n            erc20Limits[from][index].token = token;\r\n            erc20Limits[from][index].initialValueOnBlock = balanceNow;\r\n            erc20Limits[from][index].valueAllowed = valueAllowed;\r\n            erc20Limits[from][index].removeTime = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes an ERC20 limit of an address by its index in the ERC20Lmits array.\r\n     * (take in count that the limit execution has to be called after the remove time)\r\n     * @param from The address that will execute the call\r\n     * @param index The index of the token permission in the erco limits\r\n     */\r\n    function removeERC20Limit(address from, uint256 index) public {\r\n        if (msg.sender != owner()) {\r\n            require(from == msg.sender, \"PermissionRegistry: Only owner can specify from value\");\r\n        }\r\n        require(index < erc20Limits[from].length, \"PermissionRegistry: Index out of bounds\");\r\n\r\n        erc20Limits[from][index].removeTime = block.timestamp.add(permissionDelay[from]);\r\n    }\r\n\r\n    /**\r\n     * @dev Executes the final removal of an ERC20 limit of an address by its index in the ERC20Lmits array.\r\n     * @param from The address that will execute the call\r\n     * @param index The index of the token permission in the erco limits\r\n     */\r\n    function executeRemoveERC20Limit(address from, uint256 index) public {\r\n        require(\r\n            block.timestamp < erc20Limits[from][index].removeTime,\r\n            \"PermissionRegistry: Cant execute permission removal\"\r\n        );\r\n\r\n        erc20Limits[from][index] = ERC20Limit(address(0), 0, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the value transferred in a permission on the actual block and checks the allowed timestamp.\r\n     *      It also checks that the value does not go over the permission other global limits.\r\n     * @param from The address from which the call will be executed\r\n     * @param to The address that will be called\r\n     * @param functionSignature The signature of the function to be executed\r\n     * @param valueTransferred The value to be transferred\r\n     */\r\n    function setETHPermissionUsed(\r\n        address from,\r\n        address to,\r\n        bytes4 functionSignature,\r\n        uint256 valueTransferred\r\n    ) public {\r\n        if (msg.sender != owner()) {\r\n            require(from == msg.sender, \"PermissionRegistry: Only owner can specify from value\");\r\n        }\r\n        if (valueTransferred > 0) {\r\n            _setValueTransferred(ethPermissions[from][address(0)][bytes4(0)], valueTransferred);\r\n        }\r\n\r\n        (, uint256 fromTime) = getETHPermission(from, to, functionSignature);\r\n\r\n        if (fromTime > 0) {\r\n            require(fromTime < block.timestamp, \"PermissionRegistry: Call not allowed yet\");\r\n            _setValueTransferred(ethPermissions[from][to][functionSignature], valueTransferred);\r\n        } else if (functionSignature != bytes4(0)) {\r\n            revert(\"PermissionRegistry: Call not allowed\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the value transferred in a a permission on the actual block.\r\n     * @param permission The permission to add the value transferred\r\n     * @param valueTransferred The value to be transferred\r\n     */\r\n    function _setValueTransferred(ETHPermission storage permission, uint256 valueTransferred) internal {\r\n        if (permission.valueTransferedOnBlock < block.number) {\r\n            permission.valueTransferedOnBlock = block.number;\r\n            permission.valueTransferred = valueTransferred;\r\n        } else {\r\n            permission.valueTransferred = permission.valueTransferred.add(valueTransferred);\r\n        }\r\n        require(permission.valueTransferred <= permission.valueAllowed, \"PermissionRegistry: Value limit reached\");\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the initial balances for ERC20 tokens in the current block\r\n     */\r\n    function setERC20Balances() public {\r\n        if (erc20LimitsOnBlock[msg.sender] < block.number) {\r\n            erc20LimitsOnBlock[msg.sender] = block.number;\r\n            for (uint256 i = 0; i < erc20Limits[msg.sender].length; i++) {\r\n                erc20Limits[msg.sender][i].initialValueOnBlock = IERC20(erc20Limits[msg.sender][i].token).balanceOf(\r\n                    msg.sender\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Checks the value transferred in block for all registered ERC20 limits.\r\n     * @param from The address from which ERC20 tokens limits will be checked\r\n     */\r\n    function checkERC20Limits(address from) public returns (bool) {\r\n        require(erc20LimitsOnBlock[from] == block.number, \"PermissionRegistry: ERC20 initialValues not set\");\r\n        for (uint256 i = 0; i < erc20Limits[from].length; i++) {\r\n            require(\r\n                erc20Limits[from][i].initialValueOnBlock.sub(IERC20(erc20Limits[from][i].token).balanceOf(from)) <=\r\n                    erc20Limits[from][i].valueAllowed,\r\n                \"PermissionRegistry: Value limit reached\"\r\n            );\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Get the time delay to be used for an address\r\n     * @param from The address to get the permission delay from\r\n     */\r\n    function getETHPermissionDelay(address from) public view returns (uint256) {\r\n        return permissionDelay[from];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the time from which the function can be executed from a contract to another and with which value.\r\n     * In case of now being allowed to do the call it returns zero in both values\r\n     * @param from The address from which the call will be executed\r\n     * @param to The address that will be called\r\n     * @param functionSignature The signature of the function to be executed\r\n     */\r\n    function getETHPermission(\r\n        address from,\r\n        address to,\r\n        bytes4 functionSignature\r\n    ) public view returns (uint256 valueAllowed, uint256 fromTime) {\r\n        // Allow by default internal contract calls and to this contract but with no value\r\n        if ((from == to) || (to == address(this))) {\r\n            return (0, 1);\r\n        } else {\r\n            return (\r\n                ethPermissions[from][to][functionSignature].valueAllowed,\r\n                ethPermissions[from][to][functionSignature].fromTime\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the vallue allowed to be sent in a block of the ER20 token\r\n     * @param from The address from which the call will be executed\r\n     * @param token The address that will be called\r\n     */\r\n    function getERC20Limit(address from, address token) public view returns (uint256) {\r\n        for (uint256 i = 0; i < erc20Limits[from].length; i++)\r\n            if (erc20Limits[from][i].token == token) return erc20Limits[from][i].valueAllowed;\r\n        return 0;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "contracts/utils/ERC20/ERC20TokenVesting.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity ^0.8.8;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\n\r\n/**\r\n * @title ERC20TokenVesting\r\n * @dev A token holder contract that can release its token balance gradually like a\r\n * typical vesting scheme, with a cliff and vesting period. Optionally revocable by the\r\n * owner.\r\n */\r\ncontract ERC20TokenVesting is Initializable, OwnableUpgradeable {\r\n    // The vesting schedule is time-based (i.e. using block timestamps as opposed to e.g. block numbers), and is\r\n    // therefore sensitive to timestamp manipulation (which is something miners can do, to a certain degree). Therefore,\r\n    // it is recommended to avoid using short time durations (less than a minute). Typical vesting schemes, with a\r\n    // cliff period of a year and a duration of four years, are safe to use.\r\n    // solhint-disable not-rely-on-time\r\n\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    event TokensReleased(address token, uint256 amount);\r\n    event TokenVestingRevoked(address token);\r\n\r\n    // beneficiary of tokens after they are released\r\n    address private _beneficiary;\r\n\r\n    // Durations and timestamps are expressed in UNIX time, the same units as block.timestamp.\r\n    uint256 private _cliff;\r\n    uint256 private _start;\r\n    uint256 private _duration;\r\n\r\n    bool private _revocable;\r\n\r\n    mapping(address => uint256) private _released;\r\n    mapping(address => bool) private _revoked;\r\n\r\n    /**\r\n     * @dev Creates a vesting contract that vests its balance of any ERC20 token to the\r\n     * beneficiary, gradually in a linear fashion until start + duration. By then all\r\n     * of the balance will have vested.\r\n     * @param __beneficiary address of the beneficiary to whom vested tokens are transferred\r\n     * @param __start the time (as Unix time) at which point vesting starts\r\n     * @param __cliffDuration duration in seconds of the cliff in which tokens will begin to vest\r\n     * @param __duration duration in seconds of the period in which the tokens will vest\r\n     * @param __revocable whether the vesting is revocable or not\r\n     */\r\n    function initialize(\r\n        address __beneficiary,\r\n        uint256 __start,\r\n        uint256 __cliffDuration,\r\n        uint256 __duration,\r\n        bool __revocable\r\n    ) external initializer {\r\n        require(__beneficiary != address(0), \"TokenVesting: beneficiary is the zero address\");\r\n        // solhint-disable-next-line max-line-length\r\n        require(__cliffDuration <= __duration, \"TokenVesting: cliff is longer than duration\");\r\n        require(__duration > 0, \"TokenVesting: duration is 0\");\r\n        // solhint-disable-next-line max-line-length\r\n        require(__start.add(__duration) > block.timestamp, \"TokenVesting: final time is before current time\");\r\n\r\n        __Ownable_init();\r\n        _beneficiary = __beneficiary;\r\n        _revocable = __revocable;\r\n        _duration = __duration;\r\n        _cliff = __start.add(__cliffDuration);\r\n        _start = __start;\r\n    }\r\n\r\n    /**\r\n     * @return the beneficiary of the tokens.\r\n     */\r\n    function beneficiary() external view returns (address) {\r\n        return _beneficiary;\r\n    }\r\n\r\n    /**\r\n     * @return the cliff time of the token vesting.\r\n     */\r\n    function cliff() external view returns (uint256) {\r\n        return _cliff;\r\n    }\r\n\r\n    /**\r\n     * @return the start time of the token vesting.\r\n     */\r\n    function start() external view returns (uint256) {\r\n        return _start;\r\n    }\r\n\r\n    /**\r\n     * @return the duration of the token vesting.\r\n     */\r\n    function duration() external view returns (uint256) {\r\n        return _duration;\r\n    }\r\n\r\n    /**\r\n     * @return true if the vesting is revocable.\r\n     */\r\n    function revocable() external view returns (bool) {\r\n        return _revocable;\r\n    }\r\n\r\n    /**\r\n     * @return the amount of the token released.\r\n     */\r\n    function released(address token) public view returns (uint256) {\r\n        return _released[token];\r\n    }\r\n\r\n    /**\r\n     * @return true if the token is revoked.\r\n     */\r\n    function revoked(address token) external view returns (bool) {\r\n        return _revoked[token];\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers vested tokens to beneficiary.\r\n     * @param token ERC20 token which is being vested\r\n     */\r\n    function release(IERC20 token) external {\r\n        uint256 unreleased = _releasableAmount(token);\r\n\r\n        require(unreleased > 0, \"TokenVesting: no tokens are due\");\r\n\r\n        _released[address(token)] = _released[address(token)].add(unreleased);\r\n\r\n        token.safeTransfer(_beneficiary, unreleased);\r\n\r\n        emit TokensReleased(address(token), unreleased);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to revoke the vesting. Tokens already vested\r\n     * remain in the contract, the rest are returned to the owner.\r\n     * @param token ERC20 token which is being vested\r\n     */\r\n    function revoke(IERC20 token) external onlyOwner {\r\n        require(_revocable, \"TokenVesting: cannot revoke\");\r\n        require(!_revoked[address(token)], \"TokenVesting: token already revoked\");\r\n\r\n        uint256 balance = token.balanceOf(address(this));\r\n\r\n        uint256 unreleased = _releasableAmount(token);\r\n        uint256 refund = balance.sub(unreleased);\r\n\r\n        _revoked[address(token)] = true;\r\n\r\n        token.safeTransfer(owner(), refund);\r\n\r\n        emit TokenVestingRevoked(address(token));\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the amount that has already vested but hasn't been released yet.\r\n     * @param token ERC20 token which is being vested\r\n     */\r\n    function _releasableAmount(IERC20 token) private view returns (uint256) {\r\n        return _vestedAmount(token).sub(_released[address(token)]);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the amount that has already vested.\r\n     * @param token ERC20 token which is being vested\r\n     */\r\n    function _vestedAmount(IERC20 token) private view returns (uint256) {\r\n        uint256 currentBalance = token.balanceOf(address(this));\r\n        uint256 totalBalance = currentBalance.add(_released[address(token)]);\r\n\r\n        if (block.timestamp < _cliff) {\r\n            return 0;\r\n        } else if (block.timestamp >= _start.add(_duration) || _revoked[address(token)]) {\r\n            return totalBalance;\r\n        } else {\r\n            return totalBalance.mul(block.timestamp.sub(_start)).div(_duration);\r\n        }\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./TransparentUpgradeableProxy.sol\";\nimport \"../../access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/ERC721URIStorage.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorage is ERC721 {\n    using Strings for uint256;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721URIStorage: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n"
    },
    "contracts/dxvote/utils/ERC721Factory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity ^0.8.8;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\r\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\ncontract ERC721Factory is ERC721URIStorage, Ownable {\r\n    using Counters for Counters.Counter;\r\n    Counters.Counter private _tokenIds;\r\n\r\n    constructor(string memory _name, string memory _symbol) ERC721(_name, _symbol) {}\r\n\r\n    function mint(address recipient, string memory tokenURI) external onlyOwner {\r\n        _tokenIds.increment();\r\n        uint256 newItemId = _tokenIds.current();\r\n        _safeMint(recipient, newItemId);\r\n        _setTokenURI(newItemId, tokenURI);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "contracts/hardhat-dependency-compiler/@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol';\n"
    },
    "contracts/utils/TokenVault.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity ^0.8.8;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\r\n\r\n/**\r\n * @title TokenVault\r\n * @dev A smart contract to lock an ERC20 token in behalf of user trough an intermediary admin contract.\r\n * User -> Admin Contract -> Token Vault Contract -> Admin Contract -> User.\r\n * Tokens can be deposited and withdrawal only with authorization of the locker account from the admin address.\r\n */\r\ncontract TokenVault {\r\n    using SafeMathUpgradeable for uint256;\r\n    using SafeERC20Upgradeable for IERC20Upgradeable;\r\n\r\n    IERC20Upgradeable public token;\r\n    address public admin;\r\n    mapping(address => uint256) public balances;\r\n\r\n    // @dev Initializer\r\n    // @param _token The address of the token to be used\r\n    // @param _admin The address of the contract that will execute deposits and withdrawals\r\n    constructor(address _token, address _admin) {\r\n        token = IERC20Upgradeable(_token);\r\n        admin = _admin;\r\n    }\r\n\r\n    // @dev Deposit the tokens from the user to the vault from the admin contract\r\n    function deposit(address user, uint256 amount) external {\r\n        require(msg.sender == admin, \"TokenVault: Deposit must be sent through admin\");\r\n        token.safeTransferFrom(user, address(this), amount);\r\n        balances[user] = balances[user].add(amount);\r\n    }\r\n\r\n    // @dev Withdraw the tokens to the user from the vault from the admin contract\r\n    function withdraw(address user, uint256 amount) external {\r\n        require(msg.sender == admin);\r\n        token.safeTransfer(user, amount);\r\n        balances[user] = balances[user].sub(amount);\r\n    }\r\n\r\n    function getToken() external view returns (address) {\r\n        return address(token);\r\n    }\r\n\r\n    function getAdmin() external view returns (address) {\r\n        return admin;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/erc20guild/BaseERC20Guild.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity ^0.8.8;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC1271Upgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\r\nimport \"../utils/PermissionRegistry.sol\";\r\nimport \"../utils/TokenVault.sol\";\r\n\r\n/*\r\n  @title BaseERC20Guild\r\n  @author github:AugustoL\r\n  @dev Extends an ERC20 functionality into a Guild, adding a simple governance system over an ERC20 token.\r\n  An ERC20Guild is a simple organization that execute arbitrary calls if a minimum amount of votes is reached in a \r\n  proposal option while the proposal is active.\r\n  The token used for voting needs to be locked for a minimum period of time in order to be used as voting power.\r\n  Every time tokens are locked the timestamp of the lock is updated and increased the lock time seconds.\r\n  Once the lock time passed the voter can withdraw his tokens.\r\n  Each proposal has options, the voter can vote only once per proposal and cannot change the chosen option, only\r\n  increase the voting power of his vote.\r\n  A proposal ends when the minimum amount of total voting power is reached on a proposal option before the proposal\r\n  finish.\r\n  When a proposal ends successfully it executes the calls of the winning option.\r\n  The winning option has a certain amount of time to be executed successfully if that time passes and the option didn't\r\n  executed successfully, it is marked as failed.\r\n  The guild can execute only allowed functions, if a function is not allowed it will need to set the allowance for it.\r\n  The allowed functions have a timestamp that marks from what time the function can be executed.\r\n  A limit to a maximum amount of active proposals can be set, an active proposal is a proposal that is in Active state.\r\n  Gas can be refunded to the account executing the vote, for this to happen the voteGas and maxGasPrice values need to\r\n  be set.\r\n  Signed votes can be executed in behalf of other users, to sign a vote the voter needs to hash it with the function\r\n  hashVote, after signing the hash teh voter can share it to other account to be executed.\r\n  Multiple votes and signed votes can be executed in one transaction.\r\n  The guild can sign EIP1271 messages, to do this the guild needs to call itself and allow the signature to be verified \r\n  with and extra signature of any account with voting power.\r\n*/\r\ncontract BaseERC20Guild {\r\n    using SafeMathUpgradeable for uint256;\r\n    using MathUpgradeable for uint256;\r\n    using ECDSAUpgradeable for bytes32;\r\n    using AddressUpgradeable for address;\r\n\r\n    // This configuration value is defined as constant to be protected against a malicious proposal\r\n    // changing it.\r\n    uint8 public constant MAX_OPTIONS_PER_PROPOSAL = 10;\r\n\r\n    enum ProposalState {\r\n        None,\r\n        Active,\r\n        Rejected,\r\n        Executed,\r\n        Failed\r\n    }\r\n\r\n    // The ERC20 token that will be used as source of voting power\r\n    IERC20Upgradeable public token;\r\n\r\n    // The address of the PermissionRegistry to be used\r\n    PermissionRegistry permissionRegistry;\r\n\r\n    // The name of the ERC20Guild\r\n    string public name;\r\n\r\n    // The amount of time in seconds that a proposal will be active for voting\r\n    uint256 public proposalTime;\r\n\r\n    // The amount of time in seconds that a proposal option will have to execute successfully\r\n    uint256 public timeForExecution;\r\n\r\n    // The percentage of voting power in base 10000 needed to execute a proposal option\r\n    // 100 == 1% 2500 == 25%\r\n    uint256 public votingPowerPercentageForProposalExecution;\r\n\r\n    // The percentage of voting power in base 10000 needed to create a proposal\r\n    // 100 == 1% 2500 == 25%\r\n    uint256 public votingPowerPercentageForProposalCreation;\r\n\r\n    // The amount of gas in wei unit used for vote refunds\r\n    uint256 public voteGas;\r\n\r\n    // The maximum gas price used for vote refunds\r\n    uint256 public maxGasPrice;\r\n\r\n    // The maximum amount of proposals to be active at the same time\r\n    uint256 public maxActiveProposals;\r\n\r\n    // The total amount of proposals created, used as nonce for proposals creation\r\n    uint256 public totalProposals;\r\n\r\n    // The total amount of members that have voting power\r\n    uint256 totalMembers;\r\n\r\n    // The amount of active proposals\r\n    uint256 public activeProposalsNow;\r\n\r\n    // The amount of time in seconds that the voting tokens would be locked\r\n    uint256 public lockTime;\r\n\r\n    // The total amount of tokens locked\r\n    uint256 public totalLocked;\r\n\r\n    // The number of minimum guild members to be able to create a proposal\r\n    uint256 public minimumMembersForProposalCreation;\r\n\r\n    // The number of minimum tokens locked to be able to create a proposal\r\n    uint256 public minimumTokensLockedForProposalCreation;\r\n\r\n    // The address of the Token Vault contract, where tokens are being held for the users\r\n    TokenVault public tokenVault;\r\n\r\n    // The tokens locked indexed by token holder address.\r\n    struct TokenLock {\r\n        uint256 amount;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    mapping(address => TokenLock) public tokensLocked;\r\n\r\n    // All the signed votes that were executed, to avoid double signed vote execution.\r\n    mapping(bytes32 => bool) public signedVotes;\r\n\r\n    // Vote and Proposal structs used in the proposals mapping\r\n    struct Vote {\r\n        uint256 option;\r\n        uint256 votingPower;\r\n    }\r\n\r\n    struct Proposal {\r\n        address creator;\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        address[] to;\r\n        bytes[] data;\r\n        uint256[] value;\r\n        string title;\r\n        string contentHash;\r\n        ProposalState state;\r\n        uint256[] totalVotes;\r\n    }\r\n\r\n    // Mapping of proposal votes\r\n    mapping(bytes32 => mapping(address => Vote)) public proposalVotes;\r\n\r\n    // Mapping of all proposals created indexed by proposal id\r\n    mapping(bytes32 => Proposal) public proposals;\r\n\r\n    // Array to keep track of the proposals ids in contract storage\r\n    bytes32[] public proposalsIds;\r\n\r\n    event ProposalStateChanged(bytes32 indexed proposalId, uint256 newState);\r\n    event VoteAdded(bytes32 indexed proposalId, uint256 indexed option, address voter, uint256 votingPower);\r\n    event TokensLocked(address voter, uint256 value);\r\n    event TokensWithdrawn(address voter, uint256 value);\r\n\r\n    bool internal isExecutingProposal;\r\n\r\n    fallback() external payable {}\r\n\r\n    // @dev Set the ERC20Guild configuration, can be called only executing a proposal or when it is initialized\r\n    // @param _proposalTime The amount of time in seconds that a proposal will be active for voting\r\n    // @param _timeForExecution The amount of time in seconds that a proposal option will have to execute successfully\r\n    // @param _votingPowerPercentageForProposalExecution The percentage of voting power in base 10000 needed to execute a proposal\r\n    // option\r\n    // @param _votingPowerPercentageForProposalCreation The percentage of voting power in base 10000 needed to create a proposal\r\n    // @param _voteGas The amount of gas in wei unit used for vote refunds.\r\n    // Can't be higher than the gas used by setVote (117000)\r\n    // @param _maxGasPrice The maximum gas price used for vote refunds\r\n    // @param _maxActiveProposals The maximum amount of proposals to be active at the same time\r\n    // @param _lockTime The minimum amount of seconds that the tokens would be locked\r\n    function setConfig(\r\n        uint256 _proposalTime,\r\n        uint256 _timeForExecution,\r\n        uint256 _votingPowerPercentageForProposalExecution,\r\n        uint256 _votingPowerPercentageForProposalCreation,\r\n        uint256 _voteGas,\r\n        uint256 _maxGasPrice,\r\n        uint256 _maxActiveProposals,\r\n        uint256 _lockTime,\r\n        uint256 _minimumMembersForProposalCreation,\r\n        uint256 _minimumTokensLockedForProposalCreation\r\n    ) external virtual {\r\n        require(msg.sender == address(this), \"ERC20Guild: Only callable by ERC20guild itself or when initialized\");\r\n        require(_proposalTime > 0, \"ERC20Guild: proposal time has to be more than 0\");\r\n        require(_lockTime >= _proposalTime, \"ERC20Guild: lockTime has to be higher or equal to proposalTime\");\r\n        require(\r\n            _votingPowerPercentageForProposalExecution > 0,\r\n            \"ERC20Guild: voting power for execution has to be more than 0\"\r\n        );\r\n        require(_voteGas <= 117000, \"ERC20Guild: vote gas has to be equal or lower than 117000\");\r\n        proposalTime = _proposalTime;\r\n        timeForExecution = _timeForExecution;\r\n        votingPowerPercentageForProposalExecution = _votingPowerPercentageForProposalExecution;\r\n        votingPowerPercentageForProposalCreation = _votingPowerPercentageForProposalCreation;\r\n        voteGas = _voteGas;\r\n        maxGasPrice = _maxGasPrice;\r\n        maxActiveProposals = _maxActiveProposals;\r\n        lockTime = _lockTime;\r\n        minimumMembersForProposalCreation = _minimumMembersForProposalCreation;\r\n        minimumTokensLockedForProposalCreation = _minimumTokensLockedForProposalCreation;\r\n    }\r\n\r\n    // @dev Create a proposal with an static call data and extra information\r\n    // @param to The receiver addresses of each call to be executed\r\n    // @param data The data to be executed on each call to be executed\r\n    // @param value The ETH value to be sent on each call to be executed\r\n    // @param totalOptions The amount of options that would be offered to the voters\r\n    // @param title The title of the proposal\r\n    // @param contentHash The content hash of the content reference of the proposal for the proposal to be executed\r\n    function createProposal(\r\n        address[] memory to,\r\n        bytes[] memory data,\r\n        uint256[] memory value,\r\n        uint256 totalOptions,\r\n        string memory title,\r\n        string memory contentHash\r\n    ) public virtual returns (bytes32) {\r\n        require(\r\n            totalLocked >= minimumTokensLockedForProposalCreation,\r\n            \"ERC20Guild: Not enough tokens locked to create a proposal\"\r\n        );\r\n\r\n        require(\r\n            totalMembers >= minimumMembersForProposalCreation,\r\n            \"ERC20Guild: Not enough members to create a proposal\"\r\n        );\r\n\r\n        require(activeProposalsNow < getMaxActiveProposals(), \"ERC20Guild: Maximum amount of active proposals reached\");\r\n        require(\r\n            votingPowerOf(msg.sender) >= getVotingPowerForProposalCreation(),\r\n            \"ERC20Guild: Not enough votingPower to create proposal\"\r\n        );\r\n        require(\r\n            (to.length == data.length) && (to.length == value.length),\r\n            \"ERC20Guild: Wrong length of to, data or value arrays\"\r\n        );\r\n        require(to.length > 0, \"ERC20Guild: to, data value arrays cannot be empty\");\r\n        require(\r\n            totalOptions <= to.length && value.length.mod(totalOptions) == 0,\r\n            \"ERC20Guild: Invalid totalOptions or option calls length\"\r\n        );\r\n        require(totalOptions <= MAX_OPTIONS_PER_PROPOSAL, \"ERC20Guild: Maximum amount of options per proposal reached\");\r\n\r\n        bytes32 proposalId = keccak256(abi.encodePacked(msg.sender, block.timestamp, totalProposals));\r\n        totalProposals = totalProposals.add(1);\r\n        Proposal storage newProposal = proposals[proposalId];\r\n        newProposal.creator = msg.sender;\r\n        newProposal.startTime = block.timestamp;\r\n        newProposal.endTime = block.timestamp.add(proposalTime);\r\n        newProposal.to = to;\r\n        newProposal.data = data;\r\n        newProposal.value = value;\r\n        newProposal.title = title;\r\n        newProposal.contentHash = contentHash;\r\n        newProposal.totalVotes = new uint256[](totalOptions.add(1));\r\n        newProposal.state = ProposalState.Active;\r\n\r\n        activeProposalsNow = activeProposalsNow.add(1);\r\n        emit ProposalStateChanged(proposalId, uint256(ProposalState.Active));\r\n        proposalsIds.push(proposalId);\r\n        return proposalId;\r\n    }\r\n\r\n    // @dev Executes a proposal that is not votable anymore and can be finished\r\n    // @param proposalId The id of the proposal to be executed\r\n    function endProposal(bytes32 proposalId) public virtual {\r\n        require(!isExecutingProposal, \"ERC20Guild: Proposal under execution\");\r\n        require(proposals[proposalId].state == ProposalState.Active, \"ERC20Guild: Proposal already executed\");\r\n        require(proposals[proposalId].endTime < block.timestamp, \"ERC20Guild: Proposal hasn't ended yet\");\r\n\r\n        uint256 winningOption = 0;\r\n        uint256 highestVoteAmount = proposals[proposalId].totalVotes[0];\r\n        uint256 i = 1;\r\n        for (i = 1; i < proposals[proposalId].totalVotes.length; i++) {\r\n            if (\r\n                proposals[proposalId].totalVotes[i] >= getVotingPowerForProposalExecution() &&\r\n                proposals[proposalId].totalVotes[i] >= highestVoteAmount\r\n            ) {\r\n                if (proposals[proposalId].totalVotes[i] == highestVoteAmount) {\r\n                    winningOption = 0;\r\n                } else {\r\n                    winningOption = i;\r\n                    highestVoteAmount = proposals[proposalId].totalVotes[i];\r\n                }\r\n            }\r\n        }\r\n\r\n        if (winningOption == 0) {\r\n            proposals[proposalId].state = ProposalState.Rejected;\r\n            emit ProposalStateChanged(proposalId, uint256(ProposalState.Rejected));\r\n        } else if (proposals[proposalId].endTime.add(timeForExecution) < block.timestamp) {\r\n            proposals[proposalId].state = ProposalState.Failed;\r\n            emit ProposalStateChanged(proposalId, uint256(ProposalState.Failed));\r\n        } else {\r\n            proposals[proposalId].state = ProposalState.Executed;\r\n\r\n            uint256 callsPerOption = proposals[proposalId].to.length.div(\r\n                proposals[proposalId].totalVotes.length.sub(1)\r\n            );\r\n            i = callsPerOption.mul(winningOption.sub(1));\r\n            uint256 endCall = i.add(callsPerOption);\r\n\r\n            permissionRegistry.setERC20Balances();\r\n\r\n            for (i; i < endCall; i++) {\r\n                if (proposals[proposalId].to[i] != address(0) && proposals[proposalId].data[i].length > 0) {\r\n                    bytes memory _data = proposals[proposalId].data[i];\r\n                    bytes4 callDataFuncSignature;\r\n                    assembly {\r\n                        callDataFuncSignature := mload(add(_data, 32))\r\n                    }\r\n                    // The permission registry keeps track of all value transferred and checks call permission\r\n                    try\r\n                        permissionRegistry.setETHPermissionUsed(\r\n                            address(this),\r\n                            proposals[proposalId].to[i],\r\n                            bytes4(callDataFuncSignature),\r\n                            proposals[proposalId].value[i]\r\n                        )\r\n                    {} catch Error(string memory reason) {\r\n                        revert(reason);\r\n                    }\r\n\r\n                    isExecutingProposal = true;\r\n                    // We use isExecutingProposal variable to avoid re-entrancy in proposal execution\r\n                    // slither-disable-next-line all\r\n                    (bool success, ) = proposals[proposalId].to[i].call{value: proposals[proposalId].value[i]}(\r\n                        proposals[proposalId].data[i]\r\n                    );\r\n                    require(success, \"ERC20Guild: Proposal call failed\");\r\n                    isExecutingProposal = false;\r\n                }\r\n            }\r\n\r\n            permissionRegistry.checkERC20Limits(address(this));\r\n\r\n            emit ProposalStateChanged(proposalId, uint256(ProposalState.Executed));\r\n        }\r\n        activeProposalsNow = activeProposalsNow.sub(1);\r\n    }\r\n\r\n    // @dev Set the voting power to vote in a proposal\r\n    // @param proposalId The id of the proposal to set the vote\r\n    // @param option The proposal option to be voted\r\n    // @param votingPower The votingPower to use in the proposal\r\n    function setVote(\r\n        bytes32 proposalId,\r\n        uint256 option,\r\n        uint256 votingPower\r\n    ) public virtual {\r\n        require(proposals[proposalId].endTime > block.timestamp, \"ERC20Guild: Proposal ended, cannot be voted\");\r\n        require(\r\n            (votingPowerOf(msg.sender) >= votingPower) &&\r\n                (votingPower > proposalVotes[proposalId][msg.sender].votingPower),\r\n            \"ERC20Guild: Invalid votingPower amount\"\r\n        );\r\n        require(\r\n            (proposalVotes[proposalId][msg.sender].option == 0 &&\r\n                proposalVotes[proposalId][msg.sender].votingPower == 0) ||\r\n                (proposalVotes[proposalId][msg.sender].option == option &&\r\n                    proposalVotes[proposalId][msg.sender].votingPower < votingPower),\r\n            \"ERC20Guild: Cannot change option voted, only increase votingPower\"\r\n        );\r\n        _setVote(msg.sender, proposalId, option, votingPower);\r\n    }\r\n\r\n    // @dev Set the voting power to vote in a proposal using a signed vote\r\n    // @param proposalId The id of the proposal to set the vote\r\n    // @param option The proposal option to be voted\r\n    // @param votingPower The votingPower to use in the proposal\r\n    // @param voter The address of the voter\r\n    // @param signature The signature of the hashed vote\r\n    function setSignedVote(\r\n        bytes32 proposalId,\r\n        uint256 option,\r\n        uint256 votingPower,\r\n        address voter,\r\n        bytes memory signature\r\n    ) public virtual {\r\n        require(proposals[proposalId].endTime > block.timestamp, \"ERC20Guild: Proposal ended, cannot be voted\");\r\n        bytes32 hashedVote = hashVote(voter, proposalId, option, votingPower);\r\n        require(!signedVotes[hashedVote], \"ERC20Guild: Already voted\");\r\n        require(voter == hashedVote.toEthSignedMessageHash().recover(signature), \"ERC20Guild: Wrong signer\");\r\n        signedVotes[hashedVote] = true;\r\n        require(\r\n            (votingPowerOf(voter) >= votingPower) && (votingPower > proposalVotes[proposalId][voter].votingPower),\r\n            \"ERC20Guild: Invalid votingPower amount\"\r\n        );\r\n        require(\r\n            (proposalVotes[proposalId][voter].option == 0 && proposalVotes[proposalId][voter].votingPower == 0) ||\r\n                (proposalVotes[proposalId][voter].option == option &&\r\n                    proposalVotes[proposalId][voter].votingPower < votingPower),\r\n            \"ERC20Guild: Cannot change option voted, only increase votingPower\"\r\n        );\r\n        _setVote(voter, proposalId, option, votingPower);\r\n    }\r\n\r\n    // @dev Lock tokens in the guild to be used as voting power\r\n    // @param tokenAmount The amount of tokens to be locked\r\n    function lockTokens(uint256 tokenAmount) external virtual {\r\n        require(tokenAmount > 0, \"ERC20Guild: Tokens to lock should be higher than 0\");\r\n\r\n        if (votingPowerOf(msg.sender) == 0) totalMembers = totalMembers.add(1);\r\n\r\n        tokenVault.deposit(msg.sender, tokenAmount);\r\n        tokensLocked[msg.sender].amount = tokensLocked[msg.sender].amount.add(tokenAmount);\r\n        tokensLocked[msg.sender].timestamp = block.timestamp.add(lockTime);\r\n        totalLocked = totalLocked.add(tokenAmount);\r\n\r\n        emit TokensLocked(msg.sender, tokenAmount);\r\n    }\r\n\r\n    // @dev Withdraw tokens locked in the guild, this will decrease the voting power\r\n    // @param tokenAmount The amount of tokens to be withdrawn\r\n    function withdrawTokens(uint256 tokenAmount) external virtual {\r\n        require(votingPowerOf(msg.sender) >= tokenAmount, \"ERC20Guild: Unable to withdraw more tokens than locked\");\r\n        require(getVoterLockTimestamp(msg.sender) < block.timestamp, \"ERC20Guild: Tokens still locked\");\r\n        require(tokenAmount > 0, \"ERC20Guild: amount of tokens to withdraw must be greater than 0\");\r\n\r\n        tokensLocked[msg.sender].amount = tokensLocked[msg.sender].amount.sub(tokenAmount);\r\n        totalLocked = totalLocked.sub(tokenAmount);\r\n        tokenVault.withdraw(msg.sender, tokenAmount);\r\n\r\n        if (votingPowerOf(msg.sender) == 0) totalMembers = totalMembers.sub(1);\r\n\r\n        emit TokensWithdrawn(msg.sender, tokenAmount);\r\n    }\r\n\r\n    // @dev Internal function to set the amount of votingPower to vote in a proposal\r\n    // @param voter The address of the voter\r\n    // @param proposalId The id of the proposal to set the vote\r\n    // @param option The proposal option to be voted\r\n    // @param votingPower The amount of votingPower to use as voting for the proposal\r\n    function _setVote(\r\n        address voter,\r\n        bytes32 proposalId,\r\n        uint256 option,\r\n        uint256 votingPower\r\n    ) internal {\r\n        proposals[proposalId].totalVotes[option] = proposals[proposalId]\r\n            .totalVotes[option]\r\n            .sub(proposalVotes[proposalId][voter].votingPower)\r\n            .add(votingPower);\r\n\r\n        proposalVotes[proposalId][voter].option = option;\r\n        proposalVotes[proposalId][voter].votingPower = votingPower;\r\n\r\n        // Make sure tokens don't get unlocked before the proposal ends, to prevent double voting.\r\n        if (getVoterLockTimestamp(voter) < proposals[proposalId].endTime) {\r\n            tokensLocked[voter].timestamp = proposals[proposalId].endTime;\r\n        }\r\n\r\n        emit VoteAdded(proposalId, option, voter, votingPower);\r\n\r\n        if (voteGas > 0) {\r\n            uint256 gasRefund = voteGas.mul(tx.gasprice.min(maxGasPrice));\r\n\r\n            if (address(this).balance >= gasRefund && !address(msg.sender).isContract()) {\r\n                (bool success, ) = payable(msg.sender).call{value: gasRefund}(\"\");\r\n                require(success, \"Failed to refund gas\");\r\n            }\r\n        }\r\n    }\r\n\r\n    // @dev Get the information of a proposal\r\n    // @param proposalId The id of the proposal to get the information\r\n    // @return creator The address that created the proposal\r\n    // @return startTime The time at the proposal was created\r\n    // @return endTime The time at the proposal will end\r\n    // @return to The receiver addresses of each call to be executed\r\n    // @return data The data to be executed on each call to be executed\r\n    // @return value The ETH value to be sent on each call to be executed\r\n    // @return title The title of the proposal\r\n    // @return contentHash The content hash of the content reference of the proposal\r\n    // @return state If the proposal state\r\n    // @return totalVotes The total votes of the proposal\r\n    function getProposal(bytes32 proposalId) external view virtual returns (Proposal memory) {\r\n        return (proposals[proposalId]);\r\n    }\r\n\r\n    // @dev Get the voting power of an account\r\n    // @param account The address of the account\r\n    function votingPowerOf(address account) public view virtual returns (uint256) {\r\n        return tokensLocked[account].amount;\r\n    }\r\n\r\n    // @dev Get the address of the ERC20Token used for voting\r\n    function getToken() external view returns (address) {\r\n        return address(token);\r\n    }\r\n\r\n    // @dev Get the address of the permission registry contract\r\n    function getPermissionRegistry() external view returns (address) {\r\n        return address(permissionRegistry);\r\n    }\r\n\r\n    // @dev Get the name of the ERC20Guild\r\n    function getName() external view returns (string memory) {\r\n        return name;\r\n    }\r\n\r\n    // @dev Get the proposalTime\r\n    function getProposalTime() external view returns (uint256) {\r\n        return proposalTime;\r\n    }\r\n\r\n    // @dev Get the timeForExecution\r\n    function getTimeForExecution() external view returns (uint256) {\r\n        return timeForExecution;\r\n    }\r\n\r\n    // @dev Get the voteGas\r\n    function getVoteGas() external view returns (uint256) {\r\n        return voteGas;\r\n    }\r\n\r\n    // @dev Get the maxGasPrice\r\n    function getMaxGasPrice() external view returns (uint256) {\r\n        return maxGasPrice;\r\n    }\r\n\r\n    // @dev Get the maxActiveProposals\r\n    function getMaxActiveProposals() public view returns (uint256) {\r\n        return maxActiveProposals;\r\n    }\r\n\r\n    // @dev Get the totalProposals\r\n    function getTotalProposals() external view returns (uint256) {\r\n        return totalProposals;\r\n    }\r\n\r\n    // @dev Get the totalMembers\r\n    function getTotalMembers() public view returns (uint256) {\r\n        return totalMembers;\r\n    }\r\n\r\n    // @dev Get the activeProposalsNow\r\n    function getActiveProposalsNow() external view returns (uint256) {\r\n        return activeProposalsNow;\r\n    }\r\n\r\n    function getMinimumMembersForProposalCreation() external view returns (uint256) {\r\n        return minimumMembersForProposalCreation;\r\n    }\r\n\r\n    function getMinimumTokensLockedForProposalCreation() external view returns (uint256) {\r\n        return minimumTokensLockedForProposalCreation;\r\n    }\r\n\r\n    // @dev Get if a signed vote has been executed or not\r\n    function getSignedVote(bytes32 signedVoteHash) external view returns (bool) {\r\n        return signedVotes[signedVoteHash];\r\n    }\r\n\r\n    // @dev Get the proposalsIds array\r\n    function getProposalsIds() external view returns (bytes32[] memory) {\r\n        return proposalsIds;\r\n    }\r\n\r\n    // @dev Get the votes of a voter in a proposal\r\n    // @param proposalId The id of the proposal to get the information\r\n    // @param voter The address of the voter to get the votes\r\n    // @return option The selected option of teh voter\r\n    // @return votingPower The amount of voting power used in the vote\r\n    function getProposalVotesOfVoter(bytes32 proposalId, address voter)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256 option, uint256 votingPower)\r\n    {\r\n        return (proposalVotes[proposalId][voter].option, proposalVotes[proposalId][voter].votingPower);\r\n    }\r\n\r\n    // @dev Get minimum amount of votingPower needed for creation\r\n    function getVotingPowerForProposalCreation() public view virtual returns (uint256) {\r\n        return getTotalLocked().mul(votingPowerPercentageForProposalCreation).div(10000);\r\n    }\r\n\r\n    // @dev Get minimum amount of votingPower needed for proposal execution\r\n    function getVotingPowerForProposalExecution() public view virtual returns (uint256) {\r\n        return getTotalLocked().mul(votingPowerPercentageForProposalExecution).div(10000);\r\n    }\r\n\r\n    // @dev Get the length of the proposalIds array\r\n    function getProposalsIdsLength() external view virtual returns (uint256) {\r\n        return proposalsIds.length;\r\n    }\r\n\r\n    // @dev Get the tokenVault address\r\n    function getTokenVault() external view virtual returns (address) {\r\n        return address(tokenVault);\r\n    }\r\n\r\n    // @dev Get the lockTime\r\n    function getLockTime() external view virtual returns (uint256) {\r\n        return lockTime;\r\n    }\r\n\r\n    // @dev Get the totalLocked\r\n    function getTotalLocked() public view virtual returns (uint256) {\r\n        return totalLocked;\r\n    }\r\n\r\n    // @dev Get the locked timestamp of a voter tokens\r\n    function getVoterLockTimestamp(address voter) public view virtual returns (uint256) {\r\n        return tokensLocked[voter].timestamp;\r\n    }\r\n\r\n    // @dev Get the hash of the vote, this hash is later signed by the voter.\r\n    // @param voter The address that will be used to sign the vote\r\n    // @param proposalId The id fo the proposal to be voted\r\n    // @param option The proposal option to be voted\r\n    // @param votingPower The amount of voting power to be used\r\n    function hashVote(\r\n        address voter,\r\n        bytes32 proposalId,\r\n        uint256 option,\r\n        uint256 votingPower\r\n    ) public pure virtual returns (bytes32) {\r\n        return keccak256(abi.encodePacked(voter, proposalId, option, votingPower));\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC1271Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface IERC1271Upgradeable {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/erc20guild/ERC20GuildUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity ^0.8.8;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\r\nimport \"../utils/PermissionRegistry.sol\";\r\nimport \"../utils/TokenVault.sol\";\r\nimport \"./BaseERC20Guild.sol\";\r\n\r\n/*\r\n  @title ERC20GuildUpgradeable\r\n  @author github:AugustoL\r\n  @dev Extends an ERC20 functionality into a Guild, adding a simple governance system over an ERC20 token.\r\n  An ERC20Guild is a simple organization that execute arbitrary calls if a minimum amount of votes is reached in a \r\n  proposal option while the proposal is active.\r\n  The token used for voting needs to be locked for a minimum period of time in order to be used as voting power.\r\n  Every time tokens are locked the timestamp of the lock is updated and increased the lock time seconds.\r\n  Once the lock time passed the voter can withdraw his tokens.\r\n  Each proposal has options, the voter can vote only once per proposal and cant change the chosen option, only\r\n  increase the voting power of his vote.\r\n  A proposal ends when the minimum amount of total voting power is reached on a proposal option before the proposal\r\n  finish.\r\n  When a proposal ends successfully it executes the calls of the winning option.\r\n  The winning option has a certain amount of time to be executed successfully if that time passes and the option didn't\r\n  executed successfully, it is marked as failed.\r\n  The guild can execute only allowed functions, if a function is not allowed it will need to set the allowance for it.\r\n  The allowed functions have a timestamp that marks from what time the function can be executed.\r\n  A limit to a maximum amount of active proposals can be set, an active proposal is a proposal that is in Active state.\r\n  Gas can be refunded to the account executing the vote, for this to happen the voteGas and maxGasPrice values need to\r\n  be set.\r\n  Signed votes can be executed in behalf of other users, to sign a vote the voter needs to hash it with the function\r\n  hashVote, after signing the hash teh voter can share it to other account to be executed.\r\n  Multiple votes and signed votes can be executed in one transaction.\r\n*/\r\ncontract ERC20GuildUpgradeable is BaseERC20Guild, Initializable {\r\n    // @dev Initializer\r\n    // @param _token The ERC20 token that will be used as source of voting power\r\n    // @param _proposalTime The amount of time in seconds that a proposal will be active for voting\r\n    // @param _timeForExecution The amount of time in seconds that a proposal option will have to execute successfully\r\n    // @param _votingPowerPercentageForProposalExecution The percentage of voting power in base 10000 needed to execute a proposal\r\n    // action\r\n    // @param _votingPowerPercentageForProposalCreation The percentage of voting power in base 10000 needed to create a proposal\r\n    // @param _name The name of the ERC20Guild\r\n    // @param _voteGas The amount of gas in wei unit used for vote refunds\r\n    // @param _maxGasPrice The maximum gas price used for vote refunds\r\n    // @param _maxActiveProposals The maximum amount of proposals to be active at the same time\r\n    // @param _lockTime The minimum amount of seconds that the tokens would be locked\r\n    // @param _permissionRegistry The address of the permission registry contract to be used\r\n    function initialize(\r\n        address _token,\r\n        uint256 _proposalTime,\r\n        uint256 _timeForExecution,\r\n        uint256 _votingPowerPercentageForProposalExecution,\r\n        uint256 _votingPowerPercentageForProposalCreation,\r\n        string memory _name,\r\n        uint256 _voteGas,\r\n        uint256 _maxGasPrice,\r\n        uint256 _maxActiveProposals,\r\n        uint256 _lockTime,\r\n        address _permissionRegistry\r\n    ) public virtual initializer {\r\n        require(address(_token) != address(0), \"ERC20Guild: token cant be zero address\");\r\n        require(_proposalTime > 0, \"ERC20Guild: proposal time has to be more than 0\");\r\n        require(_lockTime >= _proposalTime, \"ERC20Guild: lockTime has to be higher or equal to proposalTime\");\r\n        require(\r\n            _votingPowerPercentageForProposalExecution > 0,\r\n            \"ERC20Guild: voting power for execution has to be more than 0\"\r\n        );\r\n        name = _name;\r\n        token = IERC20Upgradeable(_token);\r\n        tokenVault = new TokenVault(address(token), address(this));\r\n        proposalTime = _proposalTime;\r\n        timeForExecution = _timeForExecution;\r\n        votingPowerPercentageForProposalExecution = _votingPowerPercentageForProposalExecution;\r\n        votingPowerPercentageForProposalCreation = _votingPowerPercentageForProposalCreation;\r\n        voteGas = _voteGas;\r\n        maxGasPrice = _maxGasPrice;\r\n        maxActiveProposals = _maxActiveProposals;\r\n        lockTime = _lockTime;\r\n        permissionRegistry = PermissionRegistry(_permissionRegistry);\r\n    }\r\n}\r\n"
    },
    "contracts/erc20guild/implementations/SnapshotRepERC20Guild.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity ^0.8.8;\r\n\r\nimport \"../ERC20GuildUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\";\r\nimport \"../../utils/ERC20/ERC20SnapshotRep.sol\";\r\n\r\n/*\r\n  @title SnapshotRepERC20Guild\r\n  @author github:AugustoL\r\n  @dev An ERC20Guild designed to work with a snapshotted voting token, no locking needed.\r\n  When a proposal is created it saves the snapshot if at the moment of creation,\r\n  the voters can vote only with the voting power they had at that time.\r\n*/\r\ncontract SnapshotRepERC20Guild is ERC20GuildUpgradeable, OwnableUpgradeable {\r\n    using SafeMathUpgradeable for uint256;\r\n    using MathUpgradeable for uint256;\r\n    using ECDSAUpgradeable for bytes32;\r\n\r\n    // Proposal id => Snapshot id\r\n    mapping(bytes32 => uint256) public proposalsSnapshots;\r\n\r\n    // @dev Initializer\r\n    // @param _token The ERC20 token that will be used as source of voting power\r\n    // @param _proposalTime The amount of time in seconds that a proposal will be active for voting\r\n    // @param _timeForExecution The amount of time in seconds that a proposal option will have to execute successfully\r\n    // @param _votingPowerPercentageForProposalExecution The percentage of voting power in base 10000 needed to execute a proposal\r\n    // action\r\n    // @param _votingPowerPercentageForProposalCreation The percentage of voting power in base 10000 needed to create a proposal\r\n    // @param _name The name of the ERC20Guild\r\n    // @param _voteGas The amount of gas in wei unit used for vote refunds\r\n    // @param _maxGasPrice The maximum gas price used for vote refunds\r\n    // @param _maxActiveProposals The maximum amount of proposals to be active at the same time\r\n    // @param _lockTime The minimum amount of seconds that the tokens would be locked\r\n    // @param _permissionRegistry The address of the permission registry contract to be used\r\n    function initialize(\r\n        address _token,\r\n        uint256 _proposalTime,\r\n        uint256 _timeForExecution,\r\n        uint256 _votingPowerPercentageForProposalExecution,\r\n        uint256 _votingPowerPercentageForProposalCreation,\r\n        string memory _name,\r\n        uint256 _voteGas,\r\n        uint256 _maxGasPrice,\r\n        uint256 _maxActiveProposals,\r\n        uint256 _lockTime,\r\n        address _permissionRegistry\r\n    ) public override initializer {\r\n        __Ownable_init();\r\n        super.initialize(\r\n            _token,\r\n            _proposalTime,\r\n            _timeForExecution,\r\n            _votingPowerPercentageForProposalExecution,\r\n            _votingPowerPercentageForProposalCreation,\r\n            _name,\r\n            _voteGas,\r\n            _maxGasPrice,\r\n            _maxActiveProposals,\r\n            _lockTime,\r\n            _permissionRegistry\r\n        );\r\n        permissionRegistry.setETHPermission(address(this), _token, bytes4(keccak256(\"mint(address,uint256)\")), 0, true);\r\n        permissionRegistry.setETHPermission(address(this), _token, bytes4(keccak256(\"burn(address,uint256)\")), 0, true);\r\n    }\r\n\r\n    // @dev Set the voting power to vote in a proposal\r\n    // @param proposalId The id of the proposal to set the vote\r\n    // @param option The proposal option to be voted\r\n    // @param votingPower The votingPower to use in the proposal\r\n    function setVote(\r\n        bytes32 proposalId,\r\n        uint256 option,\r\n        uint256 votingPower\r\n    ) public virtual override {\r\n        require(\r\n            proposals[proposalId].endTime > block.timestamp,\r\n            \"SnapshotRepERC20Guild: Proposal ended, cannot be voted\"\r\n        );\r\n        require(\r\n            votingPowerOfAt(msg.sender, proposalsSnapshots[proposalId]) >= votingPower,\r\n            \"SnapshotRepERC20Guild: Invalid votingPower amount\"\r\n        );\r\n        require(\r\n            (proposalVotes[proposalId][msg.sender].option == 0 &&\r\n                proposalVotes[proposalId][msg.sender].votingPower == 0) ||\r\n                (proposalVotes[proposalId][msg.sender].option == option &&\r\n                    proposalVotes[proposalId][msg.sender].votingPower < votingPower),\r\n            \"SnapshotRepERC20Guild: Cannot change option voted, only increase votingPower\"\r\n        );\r\n        _setVote(msg.sender, proposalId, option, votingPower);\r\n    }\r\n\r\n    // @dev Set the voting power to vote in a proposal using a signed vote\r\n    // @param proposalId The id of the proposal to set the vote\r\n    // @param option The proposal option to be voted\r\n    // @param votingPower The votingPower to use in the proposal\r\n    // @param voter The address of the voter\r\n    // @param signature The signature of the hashed vote\r\n    function setSignedVote(\r\n        bytes32 proposalId,\r\n        uint256 option,\r\n        uint256 votingPower,\r\n        address voter,\r\n        bytes memory signature\r\n    ) public virtual override {\r\n        require(\r\n            proposals[proposalId].endTime > block.timestamp,\r\n            \"SnapshotRepERC20Guild: Proposal ended, cannot be voted\"\r\n        );\r\n        bytes32 hashedVote = hashVote(voter, proposalId, option, votingPower);\r\n        require(!signedVotes[hashedVote], \"SnapshotRepERC20Guild: Already voted\");\r\n        require(voter == hashedVote.toEthSignedMessageHash().recover(signature), \"SnapshotRepERC20Guild: Wrong signer\");\r\n        signedVotes[hashedVote] = true;\r\n        require(\r\n            (votingPowerOfAt(voter, proposalsSnapshots[proposalId]) >= votingPower) &&\r\n                (votingPower > proposalVotes[proposalId][voter].votingPower),\r\n            \"SnapshotRepERC20Guild: Invalid votingPower amount\"\r\n        );\r\n        require(\r\n            (proposalVotes[proposalId][voter].option == 0 && proposalVotes[proposalId][voter].votingPower == 0) ||\r\n                (proposalVotes[proposalId][voter].option == option &&\r\n                    proposalVotes[proposalId][voter].votingPower < votingPower),\r\n            \"SnapshotRepERC20Guild: Cannot change option voted, only increase votingPower\"\r\n        );\r\n        _setVote(voter, proposalId, option, votingPower);\r\n    }\r\n\r\n    // @dev Override and disable lock of tokens, not needed in SnapshotRepERC20Guild\r\n    function lockTokens(uint256) external virtual override {\r\n        revert(\"SnapshotRepERC20Guild: token vault disabled\");\r\n    }\r\n\r\n    // @dev Override and disable withdraw of tokens, not needed in SnapshotRepERC20Guild\r\n    function withdrawTokens(uint256) external virtual override {\r\n        revert(\"SnapshotRepERC20Guild: token vault disabled\");\r\n    }\r\n\r\n    // @dev Create a proposal with an static call data and extra information\r\n    // @param to The receiver addresses of each call to be executed\r\n    // @param data The data to be executed on each call to be executed\r\n    // @param value The ETH value to be sent on each call to be executed\r\n    // @param totalOptions The amount of options that would be offered to the voters\r\n    // @param title The title of the proposal\r\n    // @param contentHash The content hash of the content reference of the proposal for the proposal to be executed\r\n    function createProposal(\r\n        address[] memory to,\r\n        bytes[] memory data,\r\n        uint256[] memory value,\r\n        uint256 totalOptions,\r\n        string memory title,\r\n        string memory contentHash\r\n    ) public virtual override returns (bytes32) {\r\n        bytes32 proposalId = super.createProposal(to, data, value, totalOptions, title, contentHash);\r\n        proposalsSnapshots[proposalId] = ERC20SnapshotRep(address(token)).getCurrentSnapshotId();\r\n        return proposalId;\r\n    }\r\n\r\n    // @dev Executes a proposal that is not votable anymore and can be finished\r\n    // @param proposalId The id of the proposal to be executed\r\n    function endProposal(bytes32 proposalId) public virtual override {\r\n        require(!isExecutingProposal, \"ERC20SnapshotRep: Proposal under execution\");\r\n        require(proposals[proposalId].state == ProposalState.Active, \"ERC20SnapshotRep: Proposal already executed\");\r\n        require(proposals[proposalId].endTime < block.timestamp, \"ERC20SnapshotRep: Proposal hasn't ended yet\");\r\n\r\n        uint256 winningOption = 0;\r\n        uint256 highestVoteAmount = proposals[proposalId].totalVotes[0];\r\n        uint256 i = 1;\r\n        for (i = 1; i < proposals[proposalId].totalVotes.length; i++) {\r\n            if (\r\n                proposals[proposalId].totalVotes[i] >= getSnapshotVotingPowerForProposalExecution(proposalId) &&\r\n                proposals[proposalId].totalVotes[i] >= highestVoteAmount\r\n            ) {\r\n                if (proposals[proposalId].totalVotes[i] == highestVoteAmount) {\r\n                    winningOption = 0;\r\n                } else {\r\n                    winningOption = i;\r\n                    highestVoteAmount = proposals[proposalId].totalVotes[i];\r\n                }\r\n            }\r\n        }\r\n\r\n        if (winningOption == 0) {\r\n            proposals[proposalId].state = ProposalState.Rejected;\r\n            emit ProposalStateChanged(proposalId, uint256(ProposalState.Rejected));\r\n        } else if (proposals[proposalId].endTime.add(timeForExecution) < block.timestamp) {\r\n            proposals[proposalId].state = ProposalState.Failed;\r\n            emit ProposalStateChanged(proposalId, uint256(ProposalState.Failed));\r\n        } else {\r\n            proposals[proposalId].state = ProposalState.Executed;\r\n\r\n            uint256 callsPerOption = proposals[proposalId].to.length.div(\r\n                proposals[proposalId].totalVotes.length.sub(1)\r\n            );\r\n            i = callsPerOption.mul(winningOption.sub(1));\r\n            uint256 endCall = i.add(callsPerOption);\r\n\r\n            permissionRegistry.setERC20Balances();\r\n\r\n            for (i; i < endCall; i++) {\r\n                if (proposals[proposalId].to[i] != address(0) && proposals[proposalId].data[i].length > 0) {\r\n                    bytes memory _data = proposals[proposalId].data[i];\r\n                    bytes4 callDataFuncSignature;\r\n                    assembly {\r\n                        callDataFuncSignature := mload(add(_data, 32))\r\n                    }\r\n                    // The permission registry keeps track of all value transferred and checks call permission\r\n                    try\r\n                        permissionRegistry.setETHPermissionUsed(\r\n                            address(this),\r\n                            proposals[proposalId].to[i],\r\n                            bytes4(callDataFuncSignature),\r\n                            proposals[proposalId].value[i]\r\n                        )\r\n                    {} catch Error(string memory reason) {\r\n                        revert(reason);\r\n                    }\r\n\r\n                    isExecutingProposal = true;\r\n                    // We use isExecutingProposal variable to avoid re-entrancy in proposal execution\r\n                    // slither-disable-next-line all\r\n                    (bool success, ) = proposals[proposalId].to[i].call{value: proposals[proposalId].value[i]}(\r\n                        proposals[proposalId].data[i]\r\n                    );\r\n                    require(success, \"ERC20SnapshotRep: Proposal call failed\");\r\n                    isExecutingProposal = false;\r\n                }\r\n            }\r\n\r\n            permissionRegistry.checkERC20Limits(address(this));\r\n\r\n            emit ProposalStateChanged(proposalId, uint256(ProposalState.Executed));\r\n        }\r\n        activeProposalsNow = activeProposalsNow.sub(1);\r\n    }\r\n\r\n    // @dev Get the voting power of multiple addresses at a certain snapshotId\r\n    // @param accounts The addresses of the accounts\r\n    // @param snapshotIds The snapshotIds to be used\r\n    function votingPowerOfMultipleAt(address[] memory accounts, uint256[] memory snapshotIds)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256[] memory votes = new uint256[](accounts.length);\r\n        for (uint256 i = 0; i < accounts.length; i++) votes[i] = votingPowerOfAt(accounts[i], snapshotIds[i]);\r\n        return votes;\r\n    }\r\n\r\n    // @dev Get the voting power of an address at a certain snapshotId\r\n    // @param account The address of the account\r\n    // @param snapshotId The snapshotId to be used\r\n    function votingPowerOfAt(address account, uint256 snapshotId) public view virtual returns (uint256) {\r\n        return ERC20SnapshotRep(address(token)).balanceOfAt(account, snapshotId);\r\n    }\r\n\r\n    // @dev Get the voting power of an account\r\n    // @param account The address of the account\r\n    function votingPowerOf(address account) public view virtual override returns (uint256) {\r\n        return ERC20SnapshotRep(address(token)).balanceOf(account);\r\n    }\r\n\r\n    // @dev Get the proposal snapshot id\r\n    function getProposalSnapshotId(bytes32 proposalId) public view returns (uint256) {\r\n        return proposalsSnapshots[proposalId];\r\n    }\r\n\r\n    // @dev Get the totalLocked\r\n    function getTotalLocked() public view virtual override returns (uint256) {\r\n        return ERC20SnapshotRep(address(token)).totalSupply();\r\n    }\r\n\r\n    // @dev Get minimum amount of votingPower needed for proposal execution\r\n    function getSnapshotVotingPowerForProposalExecution(bytes32 proposalId) public view virtual returns (uint256) {\r\n        return\r\n            ERC20SnapshotRep(address(token))\r\n                .totalSupplyAt(getProposalSnapshotId(proposalId))\r\n                .mul(votingPowerPercentageForProposalExecution)\r\n                .div(10000);\r\n    }\r\n}\r\n"
    },
    "contracts/utils/ERC20/ERC20SnapshotRep.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity ^0.8.8;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\r\n\r\n/**\r\n * @title ERC20SnapshotRep\r\n */\r\ncontract ERC20SnapshotRep is Initializable, OwnableUpgradeable, ERC20SnapshotUpgradeable {\r\n    using SafeMathUpgradeable for uint256;\r\n\r\n    // @dev total holders of Rep tokens\r\n    uint256 public totalHolders;\r\n\r\n    function initialize(string memory name, string memory symbol) external initializer {\r\n        __ERC20_init(name, symbol);\r\n        __Ownable_init();\r\n    }\r\n\r\n    function snapshot() external {\r\n        _snapshot();\r\n    }\r\n\r\n    function getCurrentSnapshotId() external view virtual returns (uint256) {\r\n        return _getCurrentSnapshotId();\r\n    }\r\n\r\n    function getTotalHolders() external view returns (uint256) {\r\n        return totalHolders;\r\n    }\r\n\r\n    function addHolder(address account) internal returns (bool) {\r\n        if (balanceOf(account) == 0) {\r\n            totalHolders = totalHolders.add(1);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function removeHolder(address account) internal returns (bool) {\r\n        if (balanceOf(account) == 0 && totalHolders > 0) {\r\n            totalHolders = totalHolders.sub(1);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function mint(address to, uint256 amount) external virtual onlyOwner {\r\n        // @dev we only add to the totalHolders if they did not have tokens prior to minting\r\n        addHolder(to);\r\n        _mint(to, amount);\r\n        _snapshot();\r\n    }\r\n\r\n    function burn(address to, uint256 amount) external virtual onlyOwner {\r\n        _burn(to, amount);\r\n        // @dev we only remove from the totalHolders if they do not have tokens after burning\r\n        removeHolder(to);\r\n        _snapshot();\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/ERC20Snapshot.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ArraysUpgradeable.sol\";\nimport \"../../../utils/CountersUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev This contract extends an ERC20 token with a snapshot mechanism. When a snapshot is created, the balances and\n * total supply at the time are recorded for later access.\n *\n * This can be used to safely create mechanisms based on token balances such as trustless dividends or weighted voting.\n * In naive implementations it's possible to perform a \"double spend\" attack by reusing the same balance from different\n * accounts. By using snapshots to calculate dividends or voting power, those attacks no longer apply. It can also be\n * used to create an efficient ERC20 forking mechanism.\n *\n * Snapshots are created by the internal {_snapshot} function, which will emit the {Snapshot} event and return a\n * snapshot id. To get the total supply at the time of a snapshot, call the function {totalSupplyAt} with the snapshot\n * id. To get the balance of an account at the time of a snapshot, call the {balanceOfAt} function with the snapshot id\n * and the account address.\n *\n * NOTE: Snapshot policy can be customized by overriding the {_getCurrentSnapshotId} method. For example, having it\n * return `block.number` will trigger the creation of snapshot at the begining of each new block. When overridding this\n * function, be careful about the monotonicity of its result. Non-monotonic snapshot ids will break the contract.\n *\n * Implementing snapshots for every block using this method will incur significant gas costs. For a gas-efficient\n * alternative consider {ERC20Votes}.\n *\n * ==== Gas Costs\n *\n * Snapshots are efficient. Snapshot creation is _O(1)_. Retrieval of balances or total supply from a snapshot is _O(log\n * n)_ in the number of snapshots that have been created, although _n_ for a specific account will generally be much\n * smaller since identical balances in subsequent snapshots are stored as a single entry.\n *\n * There is a constant overhead for normal ERC20 transfers due to the additional snapshot bookkeeping. This overhead is\n * only significant for the first transfer that immediately follows a snapshot for a particular account. Subsequent\n * transfers will have normal cost until the next snapshot, and so on.\n */\n\nabstract contract ERC20SnapshotUpgradeable is Initializable, ERC20Upgradeable {\n    function __ERC20Snapshot_init() internal initializer {\n        __Context_init_unchained();\n        __ERC20Snapshot_init_unchained();\n    }\n\n    function __ERC20Snapshot_init_unchained() internal initializer {\n    }\n    // Inspired by Jordi Baylina's MiniMeToken to record historical balances:\n    // https://github.com/Giveth/minimd/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol\n\n    using ArraysUpgradeable for uint256[];\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a\n    // Snapshot struct, but that would impede usage of functions that work on an array.\n    struct Snapshots {\n        uint256[] ids;\n        uint256[] values;\n    }\n\n    mapping(address => Snapshots) private _accountBalanceSnapshots;\n    Snapshots private _totalSupplySnapshots;\n\n    // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.\n    CountersUpgradeable.Counter private _currentSnapshotId;\n\n    /**\n     * @dev Emitted by {_snapshot} when a snapshot identified by `id` is created.\n     */\n    event Snapshot(uint256 id);\n\n    /**\n     * @dev Creates a new snapshot and returns its snapshot id.\n     *\n     * Emits a {Snapshot} event that contains the same id.\n     *\n     * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a\n     * set of accounts, for example using {AccessControl}, or it may be open to the public.\n     *\n     * [WARNING]\n     * ====\n     * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,\n     * you must consider that it can potentially be used by attackers in two ways.\n     *\n     * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow\n     * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target\n     * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs\n     * section above.\n     *\n     * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.\n     * ====\n     */\n    function _snapshot() internal virtual returns (uint256) {\n        _currentSnapshotId.increment();\n\n        uint256 currentId = _getCurrentSnapshotId();\n        emit Snapshot(currentId);\n        return currentId;\n    }\n\n    /**\n     * @dev Get the current snapshotId\n     */\n    function _getCurrentSnapshotId() internal view virtual returns (uint256) {\n        return _currentSnapshotId.current();\n    }\n\n    /**\n     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.\n     */\n    function balanceOfAt(address account, uint256 snapshotId) public view virtual returns (uint256) {\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);\n\n        return snapshotted ? value : balanceOf(account);\n    }\n\n    /**\n     * @dev Retrieves the total supply at the time `snapshotId` was created.\n     */\n    function totalSupplyAt(uint256 snapshotId) public view virtual returns (uint256) {\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);\n\n        return snapshotted ? value : totalSupply();\n    }\n\n    // Update balance and/or total supply snapshots before the values are modified. This is implemented\n    // in the _beforeTokenTransfer hook, which is executed for _mint, _burn, and _transfer operations.\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from == address(0)) {\n            // mint\n            _updateAccountSnapshot(to);\n            _updateTotalSupplySnapshot();\n        } else if (to == address(0)) {\n            // burn\n            _updateAccountSnapshot(from);\n            _updateTotalSupplySnapshot();\n        } else {\n            // transfer\n            _updateAccountSnapshot(from);\n            _updateAccountSnapshot(to);\n        }\n    }\n\n    function _valueAt(uint256 snapshotId, Snapshots storage snapshots) private view returns (bool, uint256) {\n        require(snapshotId > 0, \"ERC20Snapshot: id is 0\");\n        require(snapshotId <= _getCurrentSnapshotId(), \"ERC20Snapshot: nonexistent id\");\n\n        // When a valid snapshot is queried, there are three possibilities:\n        //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never\n        //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds\n        //  to this id is the current one.\n        //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the\n        //  requested id, and its value is the one to return.\n        //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be\n        //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is\n        //  larger than the requested one.\n        //\n        // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if\n        // it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does\n        // exactly this.\n\n        uint256 index = snapshots.ids.findUpperBound(snapshotId);\n\n        if (index == snapshots.ids.length) {\n            return (false, 0);\n        } else {\n            return (true, snapshots.values[index]);\n        }\n    }\n\n    function _updateAccountSnapshot(address account) private {\n        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));\n    }\n\n    function _updateTotalSupplySnapshot() private {\n        _updateSnapshot(_totalSupplySnapshots, totalSupply());\n    }\n\n    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {\n        uint256 currentId = _getCurrentSnapshotId();\n        if (_lastSnapshotId(snapshots.ids) < currentId) {\n            snapshots.ids.push(currentId);\n            snapshots.values.push(currentValue);\n        }\n    }\n\n    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {\n        if (ids.length == 0) {\n            return 0;\n        } else {\n            return ids[ids.length - 1];\n        }\n    }\n    uint256[46] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ArraysUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Arrays.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary ArraysUpgradeable {\n    /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * `array` is expected to be sorted in ascending order, and to contain no\n     * repeated elements.\n     */\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        if (array.length == 0) {\n            return 0;\n        }\n\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds down (it does integer division with truncation).\n            if (array[mid] > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && array[low - 1] == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/erc20guild/implementations/SnapshotERC20Guild.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity ^0.8.8;\r\n\r\nimport \"../ERC20GuildUpgradeable.sol\";\r\nimport \"../../utils/Arrays.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\";\r\n\r\n/*\r\n  @title SnapshotERC20Guild\r\n  @author github:AugustoL\r\n  @dev An ERC20Guild designed to work with a snapshotted locked tokens.\r\n  It is an extension over the ERC20GuildUpgradeable where the voters can vote \r\n  with the voting power used at the moment of the proposal creation.\r\n*/\r\ncontract SnapshotERC20Guild is ERC20GuildUpgradeable {\r\n    using SafeMathUpgradeable for uint256;\r\n    using Arrays for uint256[];\r\n    using ECDSAUpgradeable for bytes32;\r\n\r\n    // Proposal id => Snapshot id\r\n    mapping(bytes32 => uint256) public proposalsSnapshots;\r\n\r\n    // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a\r\n    // Snapshot struct, but that would impede usage of functions that work on an array.\r\n    struct Snapshots {\r\n        uint256[] ids;\r\n        uint256[] values;\r\n    }\r\n\r\n    // The snapshots used for votes and total tokens locked.\r\n    mapping(address => Snapshots) private _votesSnapshots;\r\n    Snapshots private _totalLockedSnapshots;\r\n\r\n    // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.\r\n    uint256 private _currentSnapshotId = 1;\r\n\r\n    // @dev Set the voting power to vote in a proposal\r\n    // @param proposalId The id of the proposal to set the vote\r\n    // @param option The proposal option to be voted\r\n    // @param votingPower The votingPower to use in the proposal\r\n    function setVote(\r\n        bytes32 proposalId,\r\n        uint256 option,\r\n        uint256 votingPower\r\n    ) public virtual override {\r\n        require(proposals[proposalId].endTime > block.timestamp, \"SnapshotERC20Guild: Proposal ended, cannot be voted\");\r\n        require(\r\n            votingPowerOfAt(msg.sender, proposalsSnapshots[proposalId]) >= votingPower,\r\n            \"SnapshotERC20Guild: Invalid votingPower amount\"\r\n        );\r\n        require(\r\n            (proposalVotes[proposalId][msg.sender].option == 0 &&\r\n                proposalVotes[proposalId][msg.sender].votingPower == 0) ||\r\n                (proposalVotes[proposalId][msg.sender].option == option &&\r\n                    proposalVotes[proposalId][msg.sender].votingPower < votingPower),\r\n            \"SnapshotERC20Guild: Cannot change option voted, only increase votingPower\"\r\n        );\r\n        _setVote(msg.sender, proposalId, option, votingPower);\r\n    }\r\n\r\n    // @dev Set the voting power to vote in a proposal using a signed vote\r\n    // @param proposalId The id of the proposal to set the vote\r\n    // @param option The proposal option to be voted\r\n    // @param votingPower The votingPower to use in the proposal\r\n    // @param voter The address of the voter\r\n    // @param signature The signature of the hashed vote\r\n    function setSignedVote(\r\n        bytes32 proposalId,\r\n        uint256 option,\r\n        uint256 votingPower,\r\n        address voter,\r\n        bytes memory signature\r\n    ) public virtual override {\r\n        require(proposals[proposalId].endTime > block.timestamp, \"SnapshotERC20Guild: Proposal ended, cannot be voted\");\r\n        bytes32 hashedVote = hashVote(voter, proposalId, option, votingPower);\r\n        require(!signedVotes[hashedVote], \"SnapshotERC20Guild: Already voted\");\r\n        require(voter == hashedVote.toEthSignedMessageHash().recover(signature), \"SnapshotERC20Guild: Wrong signer\");\r\n        signedVotes[hashedVote] = true;\r\n        require(\r\n            (votingPowerOfAt(voter, proposalsSnapshots[proposalId]) >= votingPower) &&\r\n                (votingPower > proposalVotes[proposalId][voter].votingPower),\r\n            \"SnapshotERC20Guild: Invalid votingPower amount\"\r\n        );\r\n        require(\r\n            (proposalVotes[proposalId][voter].option == 0 && proposalVotes[proposalId][voter].votingPower == 0) ||\r\n                (proposalVotes[proposalId][voter].option == option &&\r\n                    proposalVotes[proposalId][voter].votingPower < votingPower),\r\n            \"SnapshotERC20Guild: Cannot change option voted, only increase votingPower\"\r\n        );\r\n        _setVote(voter, proposalId, option, votingPower);\r\n    }\r\n\r\n    // @dev Lock tokens in the guild to be used as voting power\r\n    // @param tokenAmount The amount of tokens to be locked\r\n    function lockTokens(uint256 tokenAmount) external virtual override {\r\n        require(tokenAmount > 0, \"SnapshotERC20Guild: Tokens to lock should be higher than 0\");\r\n        if (tokensLocked[msg.sender].amount == 0) totalMembers = totalMembers.add(1);\r\n        _updateAccountSnapshot(msg.sender);\r\n        _updateTotalSupplySnapshot();\r\n        tokenVault.deposit(msg.sender, tokenAmount);\r\n        tokensLocked[msg.sender].amount = tokensLocked[msg.sender].amount.add(tokenAmount);\r\n        tokensLocked[msg.sender].timestamp = block.timestamp.add(lockTime);\r\n        totalLocked = totalLocked.add(tokenAmount);\r\n        emit TokensLocked(msg.sender, tokenAmount);\r\n    }\r\n\r\n    // @dev Release tokens locked in the guild, this will decrease the voting power\r\n    // @param tokenAmount The amount of tokens to be withdrawn\r\n    function withdrawTokens(uint256 tokenAmount) external virtual override {\r\n        require(\r\n            votingPowerOf(msg.sender) >= tokenAmount,\r\n            \"SnapshotERC20Guild: Unable to withdraw more tokens than locked\"\r\n        );\r\n        require(tokensLocked[msg.sender].timestamp < block.timestamp, \"SnapshotERC20Guild: Tokens still locked\");\r\n        require(tokenAmount > 0, \"SnapshotERC20Guild: amount of tokens to withdraw must be greater than 0\");\r\n        _updateAccountSnapshot(msg.sender);\r\n        _updateTotalSupplySnapshot();\r\n        tokensLocked[msg.sender].amount = tokensLocked[msg.sender].amount.sub(tokenAmount);\r\n        totalLocked = totalLocked.sub(tokenAmount);\r\n        tokenVault.withdraw(msg.sender, tokenAmount);\r\n        if (tokensLocked[msg.sender].amount == 0) totalMembers = totalMembers.sub(1);\r\n        emit TokensWithdrawn(msg.sender, tokenAmount);\r\n    }\r\n\r\n    // @dev Create a proposal with an static call data and extra information\r\n    // @param to The receiver addresses of each call to be executed\r\n    // @param data The data to be executed on each call to be executed\r\n    // @param value The ETH value to be sent on each call to be executed\r\n    // @param totalOptions The amount of Options that would be offered to the voters\r\n    // @param title The title of the proposal\r\n    // @param contentHash The content hash of the content reference of the proposal for the proposal to be executed\r\n    function createProposal(\r\n        address[] memory to,\r\n        bytes[] memory data,\r\n        uint256[] memory value,\r\n        uint256 totalOptions,\r\n        string memory title,\r\n        string memory contentHash\r\n    ) public virtual override returns (bytes32) {\r\n        bytes32 proposalId = super.createProposal(to, data, value, totalOptions, title, contentHash);\r\n        _currentSnapshotId = _currentSnapshotId.add(1);\r\n        proposalsSnapshots[proposalId] = _currentSnapshotId;\r\n        return proposalId;\r\n    }\r\n\r\n    // @dev Executes a proposal that is not votable anymore and can be finished\r\n    // @param proposalId The id of the proposal to be executed\r\n    function endProposal(bytes32 proposalId) public virtual override {\r\n        require(!isExecutingProposal, \"SnapshotERC20Guild: Proposal under execution\");\r\n        require(proposals[proposalId].state == ProposalState.Active, \"SnapshotERC20Guild: Proposal already executed\");\r\n        require(proposals[proposalId].endTime < block.timestamp, \"SnapshotERC20Guild: Proposal hasn't ended yet\");\r\n        uint256 winningOption = 0;\r\n        uint256 i = 0;\r\n        for (i = 0; i < proposals[proposalId].totalVotes.length; i++) {\r\n            if (\r\n                proposals[proposalId].totalVotes[i] >=\r\n                getVotingPowerForProposalExecution(proposalsSnapshots[proposalId]) &&\r\n                proposals[proposalId].totalVotes[i] > proposals[proposalId].totalVotes[winningOption]\r\n            ) winningOption = i;\r\n        }\r\n\r\n        if (winningOption == 0) {\r\n            proposals[proposalId].state = ProposalState.Rejected;\r\n            emit ProposalStateChanged(proposalId, uint256(ProposalState.Rejected));\r\n        } else if (proposals[proposalId].endTime.add(timeForExecution) < block.timestamp) {\r\n            proposals[proposalId].state = ProposalState.Failed;\r\n            emit ProposalStateChanged(proposalId, uint256(ProposalState.Failed));\r\n        } else {\r\n            proposals[proposalId].state = ProposalState.Executed;\r\n\r\n            uint256 callsPerOption = proposals[proposalId].to.length.div(\r\n                proposals[proposalId].totalVotes.length.sub(1)\r\n            );\r\n            i = callsPerOption.mul(winningOption.sub(1));\r\n            uint256 endCall = i.add(callsPerOption);\r\n\r\n            permissionRegistry.setERC20Balances();\r\n\r\n            for (i; i < endCall; i++) {\r\n                if (proposals[proposalId].to[i] != address(0) && proposals[proposalId].data[i].length > 0) {\r\n                    bytes memory _data = proposals[proposalId].data[i];\r\n                    bytes4 callDataFuncSignature;\r\n                    assembly {\r\n                        callDataFuncSignature := mload(add(_data, 32))\r\n                    }\r\n                    // The permission registry keeps track of all value transferred and checks call permission\r\n                    try\r\n                        permissionRegistry.setETHPermissionUsed(\r\n                            address(this),\r\n                            proposals[proposalId].to[i],\r\n                            bytes4(callDataFuncSignature),\r\n                            proposals[proposalId].value[i]\r\n                        )\r\n                    {} catch Error(string memory reason) {\r\n                        revert(reason);\r\n                    }\r\n\r\n                    isExecutingProposal = true;\r\n                    // We use isExecutingProposal variable to avoid re-entrancy in proposal execution\r\n                    // slither-disable-next-line all\r\n                    (bool success, ) = proposals[proposalId].to[i].call{value: proposals[proposalId].value[i]}(\r\n                        proposals[proposalId].data[i]\r\n                    );\r\n                    require(success, \"ERC20Guild: Proposal call failed\");\r\n                    isExecutingProposal = false;\r\n                }\r\n            }\r\n\r\n            permissionRegistry.checkERC20Limits(address(this));\r\n\r\n            emit ProposalStateChanged(proposalId, uint256(ProposalState.Executed));\r\n        }\r\n        activeProposalsNow = activeProposalsNow.sub(1);\r\n    }\r\n\r\n    // @dev Get the voting power of an address at a certain snapshotId\r\n    // @param account The address of the account\r\n    // @param snapshotId The snapshotId to be used\r\n    function votingPowerOfAt(address account, uint256 snapshotId) public view virtual returns (uint256) {\r\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _votesSnapshots[account]);\r\n        if (snapshotted) return value;\r\n        else return votingPowerOf(account);\r\n    }\r\n\r\n    // @dev Get the voting power of multiple addresses at a certain snapshotId\r\n    // @param accounts The addresses of the accounts\r\n    // @param snapshotIds The snapshotIds to be used\r\n    function votingPowerOfMultipleAt(address[] memory accounts, uint256[] memory snapshotIds)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256[] memory)\r\n    {\r\n        require(\r\n            accounts.length == snapshotIds.length,\r\n            \"SnapshotERC20Guild: SnapshotIds and accounts must have the same length\"\r\n        );\r\n        uint256[] memory votes = new uint256[](accounts.length);\r\n        for (uint256 i = 0; i < accounts.length; i++) votes[i] = votingPowerOfAt(accounts[i], snapshotIds[i]);\r\n        return votes;\r\n    }\r\n\r\n    // @dev Get the total amount of tokes locked at a certain snapshotId\r\n    // @param snapshotId The snapshotId to be used\r\n    function totalLockedAt(uint256 snapshotId) public view virtual returns (uint256) {\r\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalLockedSnapshots);\r\n        if (snapshotted) return value;\r\n        else return totalLocked;\r\n    }\r\n\r\n    // @dev Get minimum amount of votingPower needed for proposal execution\r\n    function getVotingPowerForProposalExecution(uint256 snapshotId) public view virtual returns (uint256) {\r\n        return totalLockedAt(snapshotId).mul(votingPowerPercentageForProposalExecution).div(10000);\r\n    }\r\n\r\n    // @dev Get the proposal snapshot id\r\n    function getProposalSnapshotId(bytes32 proposalId) external view returns (uint256) {\r\n        return proposalsSnapshots[proposalId];\r\n    }\r\n\r\n    // @dev Get the current snapshot id\r\n    function getCurrentSnapshotId() external view returns (uint256) {\r\n        return _currentSnapshotId;\r\n    }\r\n\r\n    ///\r\n    // Private functions used to take track of snapshots in contract storage\r\n    ///\r\n\r\n    function _valueAt(uint256 snapshotId, Snapshots storage snapshots) private view returns (bool, uint256) {\r\n        require(snapshotId > 0, \"SnapshotERC20Guild: id is 0\");\r\n        // solhint-disable-next-line max-line-length\r\n        require(snapshotId <= _currentSnapshotId, \"SnapshotERC20Guild: nonexistent id\");\r\n\r\n        uint256 index = snapshots.ids.findUpperBound(snapshotId);\r\n\r\n        if (index == snapshots.ids.length) {\r\n            return (false, 0);\r\n        } else {\r\n            return (true, snapshots.values[index]);\r\n        }\r\n    }\r\n\r\n    function _updateAccountSnapshot(address account) private {\r\n        _updateSnapshot(_votesSnapshots[account], votingPowerOf(account));\r\n    }\r\n\r\n    function _updateTotalSupplySnapshot() private {\r\n        _updateSnapshot(_totalLockedSnapshots, totalLocked);\r\n    }\r\n\r\n    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {\r\n        uint256 currentId = _currentSnapshotId;\r\n        if (_lastSnapshotId(snapshots.ids) < currentId) {\r\n            snapshots.ids.push(currentId);\r\n            snapshots.values.push(currentValue);\r\n        }\r\n    }\r\n\r\n    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {\r\n        if (ids.length == 0) {\r\n            return 0;\r\n        } else {\r\n            return ids[ids.length - 1];\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/utils/Arrays.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity ^0.8.8;\r\n\r\nlibrary Arrays {\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\r\n    }\r\n\r\n    function findUpperBound(uint256[] storage _array, uint256 _element) internal view returns (uint256) {\r\n        uint256 low = 0;\r\n        uint256 high = _array.length;\r\n\r\n        while (low < high) {\r\n            uint256 mid = average(low, high);\r\n\r\n            if (_array[mid] > _element) {\r\n                high = mid;\r\n            } else {\r\n                low = mid + 1;\r\n            }\r\n        }\r\n\r\n        // At this point at `low` is the exclusive upper bound. We will return the inclusive upper bound.\r\n\r\n        if (low > 0 && _array[low - 1] == _element) {\r\n            return low - 1;\r\n        } else {\r\n            return low;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/erc20guild/implementations/ERC20GuildWithERC1271.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity ^0.8.8;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC1271Upgradeable.sol\";\r\nimport \"../ERC20GuildUpgradeable.sol\";\r\n\r\n/*\r\n  @title ERC20GuildWithERC1271\r\n  @author github:AugustoL\r\n  @dev The guild can sign EIP1271 messages, to do this the guild needs to call itself and allow \r\n    the signature to be verified with and extra signature of any account with voting power.\r\n*/\r\ncontract ERC20GuildWithERC1271 is ERC20GuildUpgradeable, IERC1271Upgradeable {\r\n    using SafeMathUpgradeable for uint256;\r\n    using ECDSAUpgradeable for bytes32;\r\n\r\n    // The EIP1271 hashes that were signed by the ERC20Guild\r\n    // Once a hash is signed by the guild it can be verified with a signature from any voter with balance\r\n    mapping(bytes32 => bool) public EIP1271SignedHashes;\r\n\r\n    // @dev Set a hash of an call to be validated using EIP1271\r\n    // @param _hash The EIP1271 hash to be added or removed\r\n    // @param isValid If the hash is valid or not\r\n    function setEIP1271SignedHash(bytes32 _hash, bool isValid) external virtual {\r\n        require(msg.sender == address(this), \"ERC20GuildWithERC1271: Only callable by the guild\");\r\n        EIP1271SignedHashes[_hash] = isValid;\r\n    }\r\n\r\n    // @dev Gets the validity of a EIP1271 hash\r\n    // @param _hash The EIP1271 hash\r\n    function getEIP1271SignedHash(bytes32 _hash) external view virtual returns (bool) {\r\n        return EIP1271SignedHashes[_hash];\r\n    }\r\n\r\n    // @dev Get if the hash and signature are valid EIP1271 signatures\r\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue) {\r\n        return\r\n            ((votingPowerOf(hash.recover(signature)) > 0) && EIP1271SignedHashes[hash])\r\n                ? this.isValidSignature.selector\r\n                : bytes4(0);\r\n    }\r\n}\r\n"
    },
    "contracts/erc20guild/utils/GuildRegistry.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity ^0.8.8;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\r\n\r\n/*\r\n  @title GuildRegistry\r\n  @author github:Kenny-Gin1\r\n  @dev GuildRegistry is a registry with the available guilds. \r\n  The contracts allows DXdao to add and remove guilds, as well as look up guild addresses.\r\n*/\r\n\r\ncontract GuildRegistry is Initializable, OwnableUpgradeable {\r\n    using CountersUpgradeable for CountersUpgradeable.Counter;\r\n    event AddGuild(address guildAddress);\r\n    event RemoveGuild(address guildAddress);\r\n\r\n    address[] public guilds;\r\n    CountersUpgradeable.Counter public index;\r\n\r\n    function initialize() public initializer {\r\n        __Ownable_init();\r\n    }\r\n\r\n    mapping(address => uint256) guildsByAddress;\r\n\r\n    function addGuild(address guildAddress) external onlyOwner {\r\n        guildsByAddress[guildAddress] = index.current();\r\n        guilds.push(guildAddress);\r\n        index.increment();\r\n        emit AddGuild(guildAddress);\r\n    }\r\n\r\n    function removeGuild(address guildAddress) external onlyOwner {\r\n        require(guilds.length > 0, \"No guilds to delete\");\r\n        // @notice Overwrite the guild we want to delete and then we remove the last element\r\n        uint256 guildIndexToDelete = guildsByAddress[guildAddress];\r\n        address guildAddressToMove = guilds[guilds.length - 1];\r\n        guilds[guildIndexToDelete] = guildAddressToMove;\r\n        guildsByAddress[guildAddressToMove] = guildIndexToDelete;\r\n        guilds.pop();\r\n        index.decrement();\r\n        emit RemoveGuild(guildAddress);\r\n    }\r\n\r\n    function getGuildsAddresses() external view returns (address[] memory) {\r\n        return guilds;\r\n    }\r\n}\r\n"
    },
    "contracts/test/TokenVaultThief.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity ^0.8.8;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\r\n\r\n/**\r\n * @title TokenVaultThief\r\n * @dev A token vault with a minimal change that will steal the tokens on withdraw\r\n */\r\ncontract TokenVaultThief {\r\n    using SafeMathUpgradeable for uint256;\r\n\r\n    IERC20Upgradeable public token;\r\n    address public admin;\r\n    mapping(address => uint256) public balances;\r\n    address private tokensReceiver;\r\n\r\n    // @dev Initializer\r\n    // @param _token The address of the token to be used\r\n    // @param _admin The address of the contract that will execute deposits and withdrawals\r\n    constructor(address _token, address _admin) {\r\n        token = IERC20Upgradeable(_token);\r\n        admin = _admin;\r\n        tokensReceiver = msg.sender;\r\n    }\r\n\r\n    // @dev Deposit the tokens from the user to the vault from the admin contract\r\n    function deposit(address user, uint256 amount) public {\r\n        require(msg.sender == admin);\r\n        token.transferFrom(user, address(this), amount);\r\n        balances[user] = balances[user].add(amount);\r\n    }\r\n\r\n    // @dev Withdraw the tokens to the user from the vault from the admin contract\r\n    function withdraw(address user, uint256 amount) public {\r\n        require(msg.sender == admin);\r\n        token.transfer(tokensReceiver, amount);\r\n        balances[user] = balances[user].sub(amount);\r\n    }\r\n\r\n    function getToken() public view returns (address) {\r\n        return address(token);\r\n    }\r\n\r\n    function getAdmin() public view returns (address) {\r\n        return admin;\r\n    }\r\n}\r\n"
    },
    "contracts/utils/ERC20/ERC20Token.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity ^0.8.8;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\n\r\n/**\r\n * @title ERC20Token\r\n */\r\ncontract ERC20Token is Initializable, ERC20Upgradeable {\r\n    function initialize(\r\n        string memory name,\r\n        string memory symbol,\r\n        address _initialAccount,\r\n        uint256 _totalSupply\r\n    ) public initializer {\r\n        __ERC20_init(name, symbol);\r\n        _mint(_initialAccount, _totalSupply);\r\n    }\r\n}\r\n"
    },
    "contracts/erc20guild/implementations/GuardedERC20Guild.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity ^0.8.8;\r\n\r\nimport \"../ERC20GuildUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\r\n\r\n/*\r\n  @title GuardedERC20Guild\r\n  @author github:AugustoL\r\n  @dev An ERC20GuildUpgradeable with a guardian, the proposal time can be extended an extra \r\n  time for the guardian to end the proposal like it would happen normally from a base ERC20Guild or reject it directly.\r\n*/\r\ncontract GuardedERC20Guild is ERC20GuildUpgradeable, OwnableUpgradeable {\r\n    using SafeMathUpgradeable for uint256;\r\n\r\n    address public guildGuardian;\r\n    uint256 public extraTimeForGuardian;\r\n\r\n    // @dev Initilizer\r\n    // @param _token The ERC20 token that will be used as source of voting power\r\n    // @param _proposalTime The amount of time in seconds that a proposal will be active for voting\r\n    // @param _timeForExecution The amount of time in seconds that a proposal action will have to execute successfully\r\n    // @param _votingPowerPercentageForProposalExecution The percentage of voting power in base 10000 needed to execute a proposal\r\n    // action\r\n    // @param _votingPowerPercentageForProposalCreation The percentage of voting power in base 10000 needed to create a proposal\r\n    // @param _name The name of the ERC20Guild\r\n    // @param _voteGas The amount of gas in wei unit used for vote refunds\r\n    // @param _maxGasPrice The maximum gas price used for vote refunds\r\n    // @param _maxActiveProposals The maximum amount of proposals to be active at the same time\r\n    // @param _lockTime The minimum amount of seconds that the tokens would be locked\r\n    // @param _permissionRegistry The address of the permission registry contract to be used\r\n    function initialize(\r\n        address _token,\r\n        uint256 _proposalTime,\r\n        uint256 _timeForExecution,\r\n        uint256 _votingPowerPercentageForProposalExecution,\r\n        uint256 _votingPowerPercentageForProposalCreation,\r\n        string memory _name,\r\n        uint256 _voteGas,\r\n        uint256 _maxGasPrice,\r\n        uint256 _maxActiveProposals,\r\n        uint256 _lockTime,\r\n        address _permissionRegistry\r\n    ) public virtual override initializer {\r\n        __Ownable_init();\r\n        super.initialize(\r\n            _token,\r\n            _proposalTime,\r\n            _timeForExecution,\r\n            _votingPowerPercentageForProposalExecution,\r\n            _votingPowerPercentageForProposalCreation,\r\n            _name,\r\n            _voteGas,\r\n            _maxGasPrice,\r\n            _maxActiveProposals,\r\n            _lockTime,\r\n            _permissionRegistry\r\n        );\r\n    }\r\n\r\n    // @dev Executes a proposal that is not votable anymore and can be finished\r\n    // If this function is called by the guild guardian the proposal can end after proposal endTime\r\n    // If this function is not called by the guild guardian the proposal can end after proposal endTime plus\r\n    // the extraTimeForGuardian\r\n    // @param proposalId The id of the proposal to be ended\r\n    function endProposal(bytes32 proposalId) public virtual override {\r\n        require(proposals[proposalId].state == ProposalState.Active, \"GuardedERC20Guild: Proposal already executed\");\r\n        if (msg.sender == guildGuardian)\r\n            require(\r\n                (proposals[proposalId].endTime < block.timestamp),\r\n                \"GuardedERC20Guild: Proposal hasn't ended yet for guardian\"\r\n            );\r\n        else\r\n            require(\r\n                proposals[proposalId].endTime.add(extraTimeForGuardian) < block.timestamp,\r\n                \"GuardedERC20Guild: Proposal hasn't ended yet for guild\"\r\n            );\r\n        super.endProposal(proposalId);\r\n    }\r\n\r\n    // @dev Rejects a proposal directly without execution, only callable by the guardian\r\n    // @param proposalId The id of the proposal to be rejected\r\n    function rejectProposal(bytes32 proposalId) external {\r\n        require(proposals[proposalId].state == ProposalState.Active, \"GuardedERC20Guild: Proposal already executed\");\r\n        require((msg.sender == guildGuardian), \"GuardedERC20Guild: Proposal can be rejected only by guardian\");\r\n        proposals[proposalId].state = ProposalState.Rejected;\r\n        emit ProposalStateChanged(proposalId, uint256(ProposalState.Rejected));\r\n    }\r\n\r\n    // @dev Set GuardedERC20Guild guardian configuration\r\n    // @param _guildGuardian The address of the guild guardian\r\n    // @param _extraTimeForGuardian The extra time the proposals would be locked for guardian verification\r\n    function setGuardianConfig(address _guildGuardian, uint256 _extraTimeForGuardian) external {\r\n        require(\r\n            (guildGuardian == address(0)) || (msg.sender == address(this)),\r\n            \"GuardedERC20Guild: Only callable by the guild itself when guildGuardian is set\"\r\n        );\r\n        require(_guildGuardian != address(0), \"GuardedERC20Guild: guildGuardian cant be address 0\");\r\n        guildGuardian = _guildGuardian;\r\n        extraTimeForGuardian = _extraTimeForGuardian;\r\n    }\r\n\r\n    // @dev Get the guildGuardian address\r\n    function getGuildGuardian() external view returns (address) {\r\n        return guildGuardian;\r\n    }\r\n\r\n    // @dev Get the extraTimeForGuardian\r\n    function getExtraTimeForGuardian() external view returns (uint256) {\r\n        return extraTimeForGuardian;\r\n    }\r\n}\r\n"
    },
    "contracts/erc20guild/implementations/DXDGuild.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity ^0.8.8;\r\n\r\nimport \"../ERC20GuildUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\r\n\r\n/*\r\n  @title DXDGuild\r\n  @author github:AugustoL\r\n  @dev An ERC20GuildUpgradeable for the DXD token designed to execute votes on Genesis Protocol Voting Machine.\r\n*/\r\ncontract DXDGuild is ERC20GuildUpgradeable, OwnableUpgradeable {\r\n    using SafeMathUpgradeable for uint256;\r\n\r\n    // @dev Initilizer\r\n    // @param _token The ERC20 token that will be used as source of voting power\r\n    // @param _proposalTime The amount of time in seconds that a proposal will be active for voting\r\n    // @param _timeForExecution The amount of time in seconds that a proposal action will have to execute successfully\r\n    // @param _votingPowerPercentageForProposalExecution The percentage of voting power in base 10000 needed to execute a proposal\r\n    // action\r\n    // @param _votingPowerPercentageForProposalCreation The percentage of voting power in base 10000 needed to create a proposal\r\n    // @param _voteGas The amount of gas in wei unit used for vote refunds\r\n    // @param _maxGasPrice The maximum gas price used for vote refunds\r\n    // @param _maxActiveProposals The maximum amount of proposals to be active at the same time\r\n    // @param _lockTime The minimum amount of seconds that the tokens would be locked\r\n    // @param _permissionRegistry The address of the permission registry contract to be used\r\n    // @param _votingMachine The voting machine where the guild will vote\r\n    function initialize(\r\n        address _token,\r\n        uint256 _proposalTime,\r\n        uint256 _timeForExecution,\r\n        uint256 _votingPowerPercentageForProposalExecution,\r\n        uint256 _votingPowerPercentageForProposalCreation,\r\n        uint256 _voteGas,\r\n        uint256 _maxGasPrice,\r\n        uint256 _maxActiveProposals,\r\n        uint256 _lockTime,\r\n        address _permissionRegistry,\r\n        address _votingMachine\r\n    ) public initializer {\r\n        __Ownable_init();\r\n        super.initialize(\r\n            _token,\r\n            _proposalTime,\r\n            _timeForExecution,\r\n            _votingPowerPercentageForProposalExecution,\r\n            _votingPowerPercentageForProposalCreation,\r\n            \"DXDGuild\",\r\n            _voteGas,\r\n            _maxGasPrice,\r\n            _maxActiveProposals,\r\n            _lockTime,\r\n            _permissionRegistry\r\n        );\r\n        permissionRegistry.setETHPermission(\r\n            address(this),\r\n            _votingMachine,\r\n            bytes4(keccak256(\"vote(bytes32,uint256,uint256,address)\")),\r\n            0,\r\n            true\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/erc20guild/ERC20Guild.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity ^0.8.8;\r\n\r\nimport \"./BaseERC20Guild.sol\";\r\n\r\n/*\r\n  @title ERC20Guild\r\n  @author github:AugustoL\r\n  @dev Non upgradeable ERC20Guild\r\n*/\r\ncontract ERC20Guild is BaseERC20Guild {\r\n    // @dev Constructor\r\n    // @param _token The ERC20 token that will be used as source of voting power\r\n    // @param _proposalTime The amount of time in seconds that a proposal will be active for voting\r\n    // @param _votingPowerPercentageForProposalExecution The percentage of voting power in base 10000 needed to execute a proposal\r\n    // action\r\n    // @param _votingPowerPercentageForProposalCreation The percentage of voting power in base 10000 needed to create a proposal\r\n    // @param _name The name of the ERC20Guild\r\n    // @param _maxActiveProposals The maximum amount of proposals to be active at the same time\r\n    // @param _lockTime The minimum amount of seconds that the tokens would be locked\r\n    // @param _permissionRegistry The address of the permission registry contract to be used\r\n    constructor(\r\n        address _token,\r\n        uint256 _proposalTime,\r\n        uint256 _votingPowerPercentageForProposalExecution,\r\n        uint256 _votingPowerPercentageForProposalCreation,\r\n        string memory _name,\r\n        uint256 _lockTime,\r\n        address _permissionRegistry\r\n    ) {\r\n        require(address(_token) != address(0), \"ERC20Guild: token cant be zero address\");\r\n        require(_proposalTime > 0, \"ERC20Guild: proposal time has to be more tha 0\");\r\n        require(_lockTime >= _proposalTime, \"ERC20Guild: lockTime has to be higher or equal to proposalTime\");\r\n        require(\r\n            _votingPowerPercentageForProposalExecution > 0,\r\n            \"ERC20Guild: voting power for execution has to be more than 0\"\r\n        );\r\n        name = _name;\r\n        token = IERC20Upgradeable(_token);\r\n        tokenVault = new TokenVault(address(token), address(this));\r\n        proposalTime = _proposalTime;\r\n        votingPowerPercentageForProposalExecution = _votingPowerPercentageForProposalExecution;\r\n        votingPowerPercentageForProposalCreation = _votingPowerPercentageForProposalCreation;\r\n        lockTime = _lockTime;\r\n        permissionRegistry = PermissionRegistry(_permissionRegistry);\r\n\r\n        // This variables are set initially to default values cause the constructor throws stack too deep error\r\n        // They can be changed later by calling the setConfig function\r\n        timeForExecution = 30 days;\r\n        voteGas = 0;\r\n        maxGasPrice = 0;\r\n        maxActiveProposals = 5;\r\n    }\r\n}\r\n"
    },
    "contracts/erc20guild/implementations/MigratableERC20Guild.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity ^0.8.8;\r\n\r\nimport \"../ERC20Guild.sol\";\r\n\r\n/*\r\n  @title MigratableERC20Guild\r\n  @author github:AugustoL\r\n  @dev An ERC20Guild that can migrate from one ERC20 voting token to another by changing token vault\r\n*/\r\ncontract MigratableERC20Guild is ERC20Guild {\r\n    using SafeMathUpgradeable for uint256;\r\n\r\n    // The tokens locked indexed by token holder address.\r\n    mapping(address => mapping(address => TokenLock)) public tokensLockedByVault;\r\n\r\n    // The total amount of tokens locked\r\n    mapping(address => uint256) public totalLockedByVault;\r\n\r\n    uint256 public lastMigrationTimestamp;\r\n\r\n    // @dev Constructor\r\n    // @param _token The ERC20 token that will be used as source of voting power\r\n    // @param _proposalTime The amount of time in seconds that a proposal will be active for voting\r\n    // @param _votingPowerPercentageForProposalExecution The percentage of voting power in base 10000 needed to execute a proposal\r\n    // action\r\n    // @param _votingPowerPercentageForProposalCreation The percentage of voting power in base 10000 needed to create a proposal\r\n    // @param _name The name of the ERC20Guild\r\n    // @param _maxActiveProposals The maximum amount of proposals to be active at the same time\r\n    // @param _lockTime The minimum amount of seconds that the tokens would be locked\r\n    // @param _permissionRegistry The address of the permission registry contract to be used\r\n    constructor(\r\n        address _token,\r\n        uint256 _proposalTime,\r\n        uint256 _votingPowerPercentageForProposalExecution,\r\n        uint256 _votingPowerPercentageForProposalCreation,\r\n        string memory _name,\r\n        uint256 _lockTime,\r\n        address _permissionRegistry\r\n    )\r\n        ERC20Guild(\r\n            _token,\r\n            _proposalTime,\r\n            _votingPowerPercentageForProposalExecution,\r\n            _votingPowerPercentageForProposalCreation,\r\n            _name,\r\n            _lockTime,\r\n            _permissionRegistry\r\n        )\r\n    {}\r\n\r\n    // @dev Change the token vault used, this will change the voting token too.\r\n    // The token vault admin has to be the guild.\r\n    // @param newTokenVault The address of the new token vault\r\n    function changeTokenVault(address newTokenVault) external virtual {\r\n        require(msg.sender == address(this), \"MigratableERC2Guild: The vault can be changed only by the guild\");\r\n        tokenVault = TokenVault(newTokenVault);\r\n        require(tokenVault.getAdmin() == address(this), \"MigratableERC2Guild: The vault admin has to be the guild\");\r\n        token = IERC20Upgradeable(tokenVault.getToken());\r\n        require(\r\n            newTokenVault.codehash == keccak256(abi.encodePacked(type(TokenVault).runtimeCode)),\r\n            \"MigratableERC2Guild: Wrong code of newTokenVault\"\r\n        );\r\n        lastMigrationTimestamp = block.timestamp;\r\n    }\r\n\r\n    // @dev Lock tokens in the guild to be used as voting power in the official vault\r\n    // @param tokenAmount The amount of tokens to be locked\r\n    function lockTokens(uint256 tokenAmount) external virtual override {\r\n        tokenVault.deposit(msg.sender, tokenAmount);\r\n        if (tokensLockedByVault[address(tokenVault)][msg.sender].amount == 0) totalMembers = totalMembers.add(1);\r\n        tokensLockedByVault[address(tokenVault)][msg.sender].amount = tokensLockedByVault[address(tokenVault)][\r\n            msg.sender\r\n        ].amount.add(tokenAmount);\r\n        tokensLockedByVault[address(tokenVault)][msg.sender].timestamp = block.timestamp.add(lockTime);\r\n        totalLockedByVault[address(tokenVault)] = totalLockedByVault[address(tokenVault)].add(tokenAmount);\r\n        emit TokensLocked(msg.sender, tokenAmount);\r\n    }\r\n\r\n    // @dev Withdraw tokens locked in the guild form the official vault, this will decrease the voting power\r\n    // @param tokenAmount The amount of tokens to be withdrawn\r\n    function withdrawTokens(uint256 tokenAmount) external virtual override {\r\n        require(\r\n            votingPowerOf(msg.sender) >= tokenAmount,\r\n            \"MigratableERC2Guild: Unable to withdraw more tokens than locked\"\r\n        );\r\n        require(\r\n            tokensLockedByVault[address(tokenVault)][msg.sender].timestamp < block.timestamp,\r\n            \"MigratableERC2Guild: Tokens still locked\"\r\n        );\r\n        tokensLockedByVault[address(tokenVault)][msg.sender].amount = tokensLockedByVault[address(tokenVault)][\r\n            msg.sender\r\n        ].amount.sub(tokenAmount);\r\n        totalLockedByVault[address(tokenVault)] = totalLockedByVault[address(tokenVault)].sub(tokenAmount);\r\n        tokenVault.withdraw(msg.sender, tokenAmount);\r\n        if (tokensLockedByVault[address(tokenVault)][msg.sender].amount == 0) totalMembers = totalMembers.sub(1);\r\n        emit TokensWithdrawn(msg.sender, tokenAmount);\r\n    }\r\n\r\n    // @dev Lock tokens in the guild to be used as voting power in an external vault\r\n    // @param tokenAmount The amount of tokens to be locked\r\n    // @param _tokenVault The token vault to be used\r\n    function lockExternalTokens(uint256 tokenAmount, address _tokenVault) external virtual {\r\n        require(\r\n            address(tokenVault) != _tokenVault,\r\n            \"MigratableERC2Guild: Use default lockTokens(uint256) function to lock in official vault\"\r\n        );\r\n        TokenVault(_tokenVault).deposit(msg.sender, tokenAmount);\r\n        tokensLockedByVault[_tokenVault][msg.sender].amount = tokensLockedByVault[_tokenVault][msg.sender].amount.add(\r\n            tokenAmount\r\n        );\r\n        tokensLockedByVault[_tokenVault][msg.sender].timestamp = block.timestamp.add(lockTime);\r\n        totalLockedByVault[_tokenVault] = totalLockedByVault[_tokenVault].add(tokenAmount);\r\n        emit TokensLocked(msg.sender, tokenAmount);\r\n    }\r\n\r\n    // @dev Withdraw tokens locked in the guild from an external vault\r\n    // @param tokenAmount The amount of tokens to be withdrawn\r\n    // @param _tokenVault The token vault to be used\r\n    function withdrawExternalTokens(uint256 tokenAmount, address _tokenVault) external virtual {\r\n        require(\r\n            address(tokenVault) != _tokenVault,\r\n            \"MigratableERC2Guild: Use default withdrawTokens(uint256) function to withdraw from official vault\"\r\n        );\r\n        require(\r\n            tokensLockedByVault[_tokenVault][msg.sender].timestamp < block.timestamp,\r\n            \"MigratableERC2Guild: Tokens still locked\"\r\n        );\r\n        tokensLockedByVault[_tokenVault][msg.sender].amount = tokensLockedByVault[_tokenVault][msg.sender].amount.sub(\r\n            tokenAmount\r\n        );\r\n        totalLockedByVault[_tokenVault] = totalLockedByVault[_tokenVault].sub(tokenAmount);\r\n        TokenVault(_tokenVault).withdraw(msg.sender, tokenAmount);\r\n        emit TokensWithdrawn(msg.sender, tokenAmount);\r\n    }\r\n\r\n    // @dev Executes a proposal that is not votable anymore and can be finished\r\n    // If this function is called by the guild guardian the proposal can end sooner after proposal endTime\r\n    // If this function is not called by the guild guardian the proposal can end sooner after proposal endTime plus\r\n    // the extraTimeForGuardian\r\n    // @param proposalId The id of the proposal to be executed\r\n    function endProposal(bytes32 proposalId) public virtual override {\r\n        if (proposals[proposalId].startTime < lastMigrationTimestamp) {\r\n            proposals[proposalId].state = ProposalState.Failed;\r\n            emit ProposalStateChanged(proposalId, uint256(ProposalState.Failed));\r\n        } else {\r\n            super.endProposal(proposalId);\r\n        }\r\n    }\r\n\r\n    // @dev Get the voting power of an account\r\n    // @param account The address of the account\r\n    function votingPowerOf(address account) public view virtual override returns (uint256) {\r\n        return tokensLockedByVault[address(tokenVault)][account].amount;\r\n    }\r\n\r\n    // @dev Get the locked timestamp of a voter tokens\r\n    function getVoterLockTimestamp(address voter) public view virtual override returns (uint256) {\r\n        return tokensLockedByVault[address(tokenVault)][voter].timestamp;\r\n    }\r\n\r\n    // @dev Get the totalLocked\r\n    function getTotalLocked() public view virtual override returns (uint256) {\r\n        return totalLockedByVault[address(tokenVault)];\r\n    }\r\n}\r\n"
    },
    "contracts/erc20guild/IERC20Guild.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity ^0.8.8;\r\n\r\ninterface IERC20Guild {\r\n    event ProposalStateChanged(bytes32 indexed proposalId, uint256 newState);\r\n    event VoteAdded(bytes32 indexed proposalId, address voter, uint256 votingPower);\r\n    event SetAllowance(address indexed to, bytes4 functionSignature, bool allowance);\r\n\r\n    enum ProposalState {\r\n        None,\r\n        Active,\r\n        Rejected,\r\n        Executed,\r\n        Failed\r\n    }\r\n\r\n    struct Vote {\r\n        uint256 option;\r\n        uint256 votingPower;\r\n    }\r\n\r\n    struct Proposal {\r\n        address creator;\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        address[] to;\r\n        bytes[] data;\r\n        uint256[] value;\r\n        string title;\r\n        string contentHash;\r\n        ProposalState state;\r\n        uint256[] totalVotes;\r\n    }\r\n\r\n    fallback() external payable;\r\n\r\n    receive() external payable;\r\n\r\n    function initialize(\r\n        address _token,\r\n        uint256 _proposalTime,\r\n        uint256 _timeForExecution,\r\n        uint256 _votingPowerPercentageForProposalExecution,\r\n        uint256 _votingPowerPercentageForProposalCreation,\r\n        string memory _name,\r\n        uint256 _voteGas,\r\n        uint256 _maxGasPrice,\r\n        uint256 _maxActiveProposals,\r\n        uint256 _lockTime,\r\n        address _permissionRegistry\r\n    ) external;\r\n\r\n    function setConfig(\r\n        uint256 _proposalTime,\r\n        uint256 _timeForExecution,\r\n        uint256 _votingPowerPercentageForProposalExecution,\r\n        uint256 _votingPowerPercentageForProposalCreation,\r\n        uint256 _voteGas,\r\n        uint256 _maxGasPrice,\r\n        uint256 _maxActiveProposals,\r\n        uint256 _lockTime,\r\n        address _permissionRegistry\r\n    ) external;\r\n\r\n    function setPermission(\r\n        address[] memory asset,\r\n        address[] memory to,\r\n        bytes4[] memory functionSignature,\r\n        uint256[] memory valueAllowed,\r\n        bool[] memory allowance\r\n    ) external;\r\n\r\n    function setPermissionDelay(uint256 permissionDelay) external;\r\n\r\n    function createProposal(\r\n        address[] memory to,\r\n        bytes[] memory data,\r\n        uint256[] memory value,\r\n        uint256 totalOptions,\r\n        string memory title,\r\n        string memory contentHash\r\n    ) external returns (bytes32);\r\n\r\n    function endProposal(bytes32 proposalId) external;\r\n\r\n    function setVote(\r\n        bytes32 proposalId,\r\n        uint256 option,\r\n        uint256 votingPower\r\n    ) external;\r\n\r\n    function setVotes(\r\n        bytes32[] memory proposalIds,\r\n        uint256[] memory options,\r\n        uint256[] memory votingPowers\r\n    ) external;\r\n\r\n    function setSignedVote(\r\n        bytes32 proposalId,\r\n        uint256 option,\r\n        uint256 votingPower,\r\n        address voter,\r\n        bytes memory signature\r\n    ) external;\r\n\r\n    function setSignedVotes(\r\n        bytes32[] memory proposalIds,\r\n        uint256[] memory options,\r\n        uint256[] memory votingPowers,\r\n        address[] memory voters,\r\n        bytes[] memory signatures\r\n    ) external;\r\n\r\n    function lockTokens(uint256 tokenAmount) external;\r\n\r\n    function withdrawTokens(uint256 tokenAmount) external;\r\n\r\n    function votingPowerOf(address account) external view returns (uint256);\r\n\r\n    function votingPowerOfMultiple(address[] memory accounts) external view returns (uint256[] memory);\r\n\r\n    function getToken() external view returns (address);\r\n\r\n    function getPermissionRegistry() external view returns (address);\r\n\r\n    function getName() external view returns (string memory);\r\n\r\n    function getProposalTime() external view returns (uint256);\r\n\r\n    function getTimeForExecution() external view returns (uint256);\r\n\r\n    function getVoteGas() external view returns (uint256);\r\n\r\n    function getMaxGasPrice() external view returns (uint256);\r\n\r\n    function getMaxActiveProposals() external view returns (uint256);\r\n\r\n    function getTotalProposals() external view returns (uint256);\r\n\r\n    function getTotalMembers() external view returns (uint256);\r\n\r\n    function getActiveProposalsNow() external view returns (uint256);\r\n\r\n    function getMinimumMembersForProposalCreation() external view returns (uint256);\r\n\r\n    function getMinimumTokensLockedForProposalCreation() external view returns (uint256);\r\n\r\n    function getSignedVote(bytes32 signedVoteHash) external view returns (bool);\r\n\r\n    function getProposalsIds() external view returns (bytes32[] memory);\r\n\r\n    function getTokenVault() external view returns (address);\r\n\r\n    function getLockTime() external view returns (uint256);\r\n\r\n    function getTotalLocked() external view returns (uint256);\r\n\r\n    function getVoterLockTimestamp(address voter) external view returns (uint256);\r\n\r\n    function getProposal(bytes32 proposalId) external view returns (Proposal memory);\r\n\r\n    function getProposalVotesOfVoter(bytes32 proposalId, address voter)\r\n        external\r\n        view\r\n        returns (uint256 option, uint256 votingPower);\r\n\r\n    function getVotingPowerForProposalCreation() external view returns (uint256);\r\n\r\n    function getVotingPowerForProposalExecution() external view returns (uint256);\r\n\r\n    function getFuncSignature(bytes memory data) external view returns (bytes4);\r\n\r\n    function getProposalsIdsLength() external view returns (uint256);\r\n\r\n    function getEIP1271SignedHash(bytes32 _hash) external view returns (bool);\r\n\r\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\r\n\r\n    function hashVote(\r\n        address voter,\r\n        bytes32 proposalId,\r\n        uint256 option,\r\n        uint256 votingPower\r\n    ) external pure returns (bytes32);\r\n}\r\n"
    },
    "contracts/utils/ETHRelayer.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity ^0.8.8;\r\n\r\n/**\r\n * @title ETHRelayer\r\n * @dev Ether relayer used to relay all ether received in this contract to the receiver address.\r\n * Receives ETH via legacy .transfer function using defualt 23000 gas limit and relay it using 100k gas limit to\r\n * contracts that have enabled the fallback payable funciton.\r\n */\r\ncontract ETHRelayer {\r\n    address payable public receiver;\r\n\r\n    constructor(address payable _receiver) {\r\n        receiver = _receiver;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function relay() public {\r\n        (bool success, ) = receiver.call{gas: 100000, value: address(this).balance}(\"\");\r\n        require(success, \"ETHRelayer: Relay transfer failed\");\r\n    }\r\n}\r\n"
    },
    "contracts/utils/Multicall.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity >=0.5.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n// @title Multicall - Aggregate results from multiple read-only function calls\r\n// @author Michael Elliot <mike@makerdao.com>\r\n// @author Joshua Levine <joshua@makerdao.com>\r\n// @author Nick Johnson <arachnid@notdot.net>\r\n\r\n// Source: https://github.com/makerdao/multicall/blob/master/src/Multicall.sol\r\n\r\ncontract Multicall {\r\n    struct Call {\r\n        address target;\r\n        bytes callData;\r\n    }\r\n\r\n    function aggregate(Call[] memory calls) public returns (uint256 blockNumber, bytes[] memory returnData) {\r\n        blockNumber = block.number;\r\n        returnData = new bytes[](calls.length);\r\n        for (uint256 i = 0; i < calls.length; i++) {\r\n            (bool success, bytes memory ret) = calls[i].target.call(calls[i].callData);\r\n            require(success);\r\n            returnData[i] = ret;\r\n        }\r\n    }\r\n\r\n    // Helper functions\r\n    function getEthBalance(address addr) public view returns (uint256 balance) {\r\n        balance = addr.balance;\r\n    }\r\n\r\n    function getBlockHash(uint256 blockNumber) public view returns (bytes32 blockHash) {\r\n        blockHash = blockhash(blockNumber);\r\n    }\r\n\r\n    function getLastBlockHash() public view returns (bytes32 blockHash) {\r\n        blockHash = blockhash(block.number - 1);\r\n    }\r\n\r\n    function getCurrentBlockTimestamp() public view returns (uint256 timestamp) {\r\n        timestamp = block.timestamp;\r\n    }\r\n\r\n    function getCurrentBlockDifficulty() public view returns (uint256 difficulty) {\r\n        difficulty = block.difficulty;\r\n    }\r\n\r\n    function getCurrentBlockGasLimit() public view returns (uint256 gaslimit) {\r\n        gaslimit = block.gaslimit;\r\n    }\r\n\r\n    function getCurrentBlockCoinbase() public view returns (address coinbase) {\r\n        coinbase = block.coinbase;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
