{
  "language": "Solidity",
  "sources": {
    "contracts/dxd/DecentralizedAutonomousTrust.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"./interfaces/IWhitelist.sol\";\nimport \"./math/BigDiv.sol\";\nimport \"./math/Sqrt.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Detailed.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol\";\n\n\n/**\n * @title Decentralized Autonomous Trust\n * This contract is a modified version of the implementation provided by Fairmint for a\n * Decentralized Autonomous Trust as described in the continuous\n * organization whitepaper (https://github.com/c-org/whitepaper) and\n * specified here: https://github.com/fairmint/c-org/wiki.\n * Code from : https://github.com/Fairmint/c-org/blob/dfd3129f9bce8717406aba54d1f1888d8e253dbb/contracts/DecentralizedAutonomousTrust.sol\n * Changes Added: https://github.com/Fairmint/c-org/commit/60bb63b9112a82996f275a75a87c28b1d73e3f11\n *\n * Use at your own risk. \n */\ncontract DecentralizedAutonomousTrust\n  is ERC20, ERC20Detailed\n{\n  using SafeMath for uint;\n  using Sqrt for uint;\n  using SafeERC20 for IERC20;\n\n  /**\n   * Events\n   */\n\n  event Buy(\n    address indexed _from,\n    address indexed _to,\n    uint _currencyValue,\n    uint _fairValue\n  );\n  event Sell(\n    address indexed _from,\n    address indexed _to,\n    uint _currencyValue,\n    uint _fairValue\n  );\n  event Burn(\n    address indexed _from,\n    uint _fairValue\n  );\n  event Pay(\n    address indexed _from,\n    address indexed _to,\n    uint _currencyValue,\n    uint _fairValue\n  );\n  event Close(\n    uint _exitFee\n  );\n  event StateChange(\n    uint _previousState,\n    uint _newState\n  );\n  event UpdateConfig(\n    address _whitelistAddress,\n    address indexed _beneficiary,\n    address indexed _control,\n    address indexed _feeCollector,\n    bool _autoBurn,\n    uint _revenueCommitmentBasisPoints,\n    uint _feeBasisPoints,\n    uint _minInvestment,\n    uint _openUntilAtLeast\n  );\n\n  /**\n   * Constants\n   */\n\n  /// @notice The default state\n  uint private constant STATE_INIT = 0;\n\n  /// @notice The state after initGoal has been reached\n  uint private constant STATE_RUN = 1;\n\n  /// @notice The state after closed by the `beneficiary` account from STATE_RUN\n  uint private constant STATE_CLOSE = 2;\n\n  /// @notice The state after closed by the `beneficiary` account from STATE_INIT\n  uint private constant STATE_CANCEL = 3;\n\n  /// @notice When multiplying 2 terms, the max value is 2^128-1\n  uint private constant MAX_BEFORE_SQUARE = 2**128 - 1;\n\n  /// @notice The denominator component for values specified in basis points.\n  uint private constant BASIS_POINTS_DEN = 10000;\n\n  /// @notice The max `totalSupply() + burnedSupply`\n  /// @dev This limit ensures that the DAT's formulas do not overflow (<MAX_BEFORE_SQUARE/2)\n  uint private constant MAX_SUPPLY = 10 ** 38;\n\n  /**\n   * Data specific to our token business logic\n   */\n\n  /// @notice The contract for transfer authorizations, if any.\n  IWhitelist public whitelist;\n\n  /// @notice The total number of burned COT tokens, excluding tokens burned from a `Sell` action in the DAT.\n  uint public burnedSupply;\n\n  /**\n   * Data for DAT business logic\n   */\n\n  /// @notice Set if the COTs minted by the organization when it commits its revenues are\n  /// automatically burnt (`true`) or not (`false`). Defaults to `false` meaning that there\n  /// is no automatic burn.\n  bool public autoBurn;\n\n  /// @notice The address of the beneficiary organization which receives the investments.\n  /// Points to the wallet of the organization.\n  address payable public beneficiary;\n\n  /// @notice The buy slope of the bonding curve.\n  /// Does not affect the financial model, only the granularity of COT.\n  /// @dev This is the numerator component of the fractional value.\n  uint public buySlopeNum;\n\n  /// @notice The buy slope of the bonding curve.\n  /// Does not affect the financial model, only the granularity of COT.\n  /// @dev This is the denominator component of the fractional value.\n  uint public buySlopeDen;\n\n  /// @notice The address from which the updatable variables can be updated\n  address public control;\n\n  /// @notice The address of the token used as reserve in the bonding curve\n  /// (e.g. the DAI contract). Use ETH if 0.\n  IERC20 public currency;\n\n  /// @notice The address where fees are sent.\n  address payable public feeCollector;\n\n  /// @notice The percent fee collected each time new COT are issued expressed in basis points.\n  uint public feeBasisPoints;\n\n  /// @notice The initial fundraising goal (expressed in COT) to start the c-org.\n  /// `0` means that there is no initial fundraising and the c-org immediately moves to run state.\n  uint public initGoal;\n\n  /// @notice A map with all investors in init state using address as a key and amount as value.\n  /// @dev This structure's purpose is to make sure that only investors can withdraw their money if init_goal is not reached.\n  mapping(address => uint) public initInvestors;\n\n  /// @notice The initial number of COT created at initialization for the beneficiary.\n  /// Technically however, this variable is not a constant as we must always have\n  ///`init_reserve>=total_supply+burnt_supply` which means that `init_reserve` will be automatically\n  /// decreased to equal `total_supply+burnt_supply` in case `init_reserve>total_supply+burnt_supply`\n  /// after an investor sells his COTs.\n  /// @dev Organizations may move these tokens into vesting contract(s)\n  uint public initReserve;\n\n  /// @notice The investment reserve of the c-org. Defines the percentage of the value invested that is\n  /// automatically funneled and held into the buyback_reserve expressed in basis points.\n  uint public investmentReserveBasisPoints;\n\n  /// @notice The earliest date/time (in seconds) that the DAT may enter the `CLOSE` state, ensuring\n  /// that if the DAT reaches the `RUN` state it will remain running for at least this period of time.\n  /// @dev This value may be increased anytime by the control account\n  uint public openUntilAtLeast;\n\n  /// @notice The minimum amount of `currency` investment accepted.\n  uint public minInvestment;\n\n  /// @notice The revenue commitment of the organization. Defines the percentage of the value paid through the contract\n  /// that is automatically funneled and held into the buyback_reserve expressed in basis points.\n  uint public revenueCommitmentBasisPoints;\n\n  /// @notice The current state of the contract.\n  /// @dev See the constants above for possible state values.\n  uint public state;\n\n  string public constant version = \"2\";\n  // --- EIP712 niceties ---\n  // Original source: https://etherscan.io/address/0x6b175474e89094c44da98b954eedeac495271d0f#code\n  mapping (address => uint) public nonces;\n  bytes32 public DOMAIN_SEPARATOR;\n  // bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\");\n  bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\n\n  modifier authorizeTransfer(\n    address _from,\n    address _to,\n    uint _value,\n    bool _isSell\n  )\n  {\n    if(address(whitelist) != address(0))\n    {\n      // This is not set for the minting of initialReserve\n      whitelist.authorizeTransfer(_from, _to, _value, _isSell);\n    }\n    _;\n  }\n\n  /**\n   * Buyback reserve\n   */\n\n  /// @notice The total amount of currency value currently locked in the contract and available to sellers.\n  function buybackReserve() public view returns (uint)\n  {\n    uint reserve = address(this).balance;\n    if(address(currency) != address(0))\n    {\n      reserve = currency.balanceOf(address(this));\n    }\n\n    if(reserve > MAX_BEFORE_SQUARE)\n    {\n      /// Math: If the reserve becomes excessive, cap the value to prevent overflowing in other formulas\n      return MAX_BEFORE_SQUARE;\n    }\n\n    return reserve;\n  }\n\n  /**\n   * Functions required for the whitelist\n   */\n\n  function _detectTransferRestriction(\n    address _from,\n    address _to,\n    uint _value\n  ) private view\n    returns (uint)\n  {\n    if(address(whitelist) != address(0))\n    {\n      // This is not set for the minting of initialReserve\n      return whitelist.detectTransferRestriction(_from, _to, _value);\n    }\n\n    return 0;\n  }\n\n  /**\n   * Functions required by the ERC-20 token standard\n   */\n\n  /// @dev Moves tokens from one account to another if authorized.\n  function _transfer(\n    address _from,\n    address _to,\n    uint _amount\n  ) internal\n    authorizeTransfer(_from, _to, _amount, false)\n  {\n    require(state != STATE_INIT || _from == beneficiary, \"ONLY_BENEFICIARY_DURING_INIT\");\n    super._transfer(_from, _to, _amount);\n  }\n\n  /// @dev Removes tokens from the circulating supply.\n  function _burn(\n    address _from,\n    uint _amount,\n    bool _isSell\n  ) internal\n    authorizeTransfer(_from, address(0), _amount, _isSell)\n  {\n    super._burn(_from, _amount);\n\n    if(!_isSell)\n    {\n      // This is a burn\n      require(state == STATE_RUN, \"ONLY_DURING_RUN\");\n      // SafeMath not required as we cap how high this value may get during mint\n      burnedSupply += _amount;\n      emit Burn(_from, _amount);\n    }\n  }\n\n  /// @notice Called to mint tokens on `buy`.\n  function _mint(\n    address _to,\n    uint _quantity\n  ) internal\n    authorizeTransfer(address(0), _to, _quantity, false)\n  {\n    super._mint(_to, _quantity);\n\n    // Math: If this value got too large, the DAT may overflow on sell\n    require(totalSupply().add(burnedSupply) <= MAX_SUPPLY, \"EXCESSIVE_SUPPLY\");\n  }\n\n  /**\n   * Transaction Helpers\n   */\n\n  /// @notice Confirms the transfer of `_quantityToInvest` currency to the contract.\n  function _collectInvestment(\n    uint _quantityToInvest,\n    uint _msgValue,\n    bool _refundRemainder\n  ) private\n  {\n    if(address(currency) == address(0))\n    {\n      // currency is ETH\n      if(_refundRemainder)\n      {\n        // Math: if _msgValue was not sufficient then revert\n        uint refund = _msgValue.sub(_quantityToInvest);\n        if(refund > 0)\n        {\n          Address.sendValue(msg.sender, refund);\n        }\n      }\n      else\n      {\n        require(_quantityToInvest == _msgValue, \"INCORRECT_MSG_VALUE\");\n      }\n    }\n    else\n    {\n      // currency is ERC20\n      require(_msgValue == 0, \"DO_NOT_SEND_ETH\");\n\n      currency.safeTransferFrom(msg.sender, address(this), _quantityToInvest);\n    }\n  }\n\n  /// @dev Send `_amount` currency from the contract to the `_to` account.\n  function _transferCurrency(\n    address payable _to,\n    uint _amount\n  ) private\n  {\n    if(_amount > 0)\n    {\n      if(address(currency) == address(0))\n      {\n        Address.sendValue(_to, _amount);\n      }\n      else\n      {\n        currency.safeTransfer(_to, _amount);\n      }\n    }\n  }\n\n  /**\n   * Config / Control\n   */\n\n  /// @notice Called once after deploy to set the initial configuration.\n  /// None of the values provided here may change once initially set.\n  /// @dev using the init pattern in order to support zos upgrades\n  function initialize(\n    uint _initReserve,\n    address _currencyAddress,\n    uint _initGoal,\n    uint _buySlopeNum,\n    uint _buySlopeDen,\n    uint _investmentReserveBasisPoints,\n    string memory _name,\n    string memory _symbol\n  ) public\n  {\n    require(control == address(0), \"ALREADY_INITIALIZED\");\n\n    ERC20Detailed.initialize(_name, _symbol, 18);\n\n    // Set initGoal, which in turn defines the initial state\n    if(_initGoal == 0)\n    {\n      emit StateChange(state, STATE_RUN);\n      state = STATE_RUN;\n    }\n    else\n    {\n      // Math: If this value got too large, the DAT would overflow on sell\n      require(_initGoal < MAX_SUPPLY, \"EXCESSIVE_GOAL\");\n      initGoal = _initGoal;\n    }\n\n    require(_buySlopeNum > 0, \"INVALID_SLOPE_NUM\");\n    require(_buySlopeDen > 0, \"INVALID_SLOPE_DEN\");\n    require(_buySlopeNum < MAX_BEFORE_SQUARE, \"EXCESSIVE_SLOPE_NUM\");\n    require(_buySlopeDen < MAX_BEFORE_SQUARE, \"EXCESSIVE_SLOPE_DEN\");\n    buySlopeNum = _buySlopeNum;\n    buySlopeDen = _buySlopeDen;\n    // 100% or less\n    require(_investmentReserveBasisPoints <= BASIS_POINTS_DEN, \"INVALID_RESERVE\");\n    investmentReserveBasisPoints = _investmentReserveBasisPoints;\n\n    // Set default values (which may be updated using `updateConfig`)\n    minInvestment = 100 ether;\n    beneficiary = msg.sender;\n    control = msg.sender;\n    feeCollector = msg.sender;\n\n    // Save currency\n    currency = IERC20(_currencyAddress);\n\n    // Mint the initial reserve\n    if(_initReserve > 0)\n    {\n      initReserve = _initReserve;\n      _mint(beneficiary, initReserve);\n    }\n\n    // Initialize permit\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n        keccak256(bytes(name())),\n        keccak256(bytes(version)),\n        getChainId(),\n        address(this)\n      )\n    );\n  }\n  function getChainId(\n  ) private pure\n    returns (uint id)\n  {\n    // solium-disable-next-line\n    assembly\n    {\n      id := chainid()\n    }\n  }\n\n  function updateConfig(\n    address _whitelistAddress,\n    address payable _beneficiary,\n    address _control,\n    address payable _feeCollector,\n    uint _feeBasisPoints,\n    bool _autoBurn,\n    uint _revenueCommitmentBasisPoints,\n    uint _minInvestment,\n    uint _openUntilAtLeast\n  ) public\n  {\n    // This require(also confirms that initialize has been called.\n    require(msg.sender == control, \"CONTROL_ONLY\");\n\n    // address(0) is okay\n    whitelist = IWhitelist(_whitelistAddress);\n\n    require(_control != address(0), \"INVALID_ADDRESS\");\n    control = _control;\n\n    require(_feeCollector != address(0), \"INVALID_ADDRESS\");\n    feeCollector = _feeCollector;\n\n    autoBurn = _autoBurn;\n\n    require(_revenueCommitmentBasisPoints <= BASIS_POINTS_DEN, \"INVALID_COMMITMENT\");\n    require(_revenueCommitmentBasisPoints >= revenueCommitmentBasisPoints, \"COMMITMENT_MAY_NOT_BE_REDUCED\");\n    revenueCommitmentBasisPoints = _revenueCommitmentBasisPoints;\n\n    require(_feeBasisPoints <= BASIS_POINTS_DEN, \"INVALID_FEE\");\n    feeBasisPoints = _feeBasisPoints;\n\n    require(_minInvestment > 0, \"INVALID_MIN_INVESTMENT\");\n    minInvestment = _minInvestment;\n\n    require(_openUntilAtLeast >= openUntilAtLeast, \"OPEN_UNTIL_MAY_NOT_BE_REDUCED\");\n    openUntilAtLeast = _openUntilAtLeast;\n\n    if(beneficiary != _beneficiary)\n    {\n      require(_beneficiary != address(0), \"INVALID_ADDRESS\");\n      uint tokens = balanceOf(beneficiary);\n      initInvestors[_beneficiary] = initInvestors[_beneficiary].add(initInvestors[beneficiary]);\n      initInvestors[beneficiary] = 0;\n      if(tokens > 0)\n      {\n        _transfer(beneficiary, _beneficiary, tokens);\n      }\n      beneficiary = _beneficiary;\n    }\n\n    emit UpdateConfig(\n      _whitelistAddress,\n      _beneficiary,\n      _control,\n      _feeCollector,\n      _autoBurn,\n      _revenueCommitmentBasisPoints,\n      _feeBasisPoints,\n      _minInvestment,\n      _openUntilAtLeast\n    );\n  }\n\n  /**\n   * Functions for our business logic\n   */\n\n  /// @notice Burn the amount of tokens from the address msg.sender if authorized.\n  /// @dev Note that this is not the same as a `sell` via the DAT.\n  function burn(\n    uint _amount\n  ) public\n  {\n    _burn(msg.sender, _amount, false);\n  }\n\n  // Buy\n\n  /// @dev Distributes _value currency between the buybackReserve, beneficiary, and feeCollector.\n  function _distributeInvestment(\n    uint _value\n  ) private\n  {\n    // Rounding favors buybackReserve, then beneficiary, and feeCollector is last priority.\n\n    // Math: if investment value is < (2^256 - 1) / 10000 this will never overflow.\n    // Except maybe with a huge single investment, but they can try again with multiple smaller investments.\n    uint reserve = investmentReserveBasisPoints.mul(_value);\n    reserve /= BASIS_POINTS_DEN;\n    reserve = _value.sub(reserve);\n    uint fee = reserve.mul(feeBasisPoints);\n    fee /= BASIS_POINTS_DEN;\n\n    // Math: since feeBasisPoints is <= BASIS_POINTS_DEN, this will never underflow.\n    _transferCurrency(beneficiary, reserve - fee);\n    _transferCurrency(feeCollector, fee);\n  }\n\n  /// @notice Calculate how many COT tokens you would buy with the given amount of currency if `buy` was called now.\n  /// @param _currencyValue How much currency to spend in order to buy COT.\n  function estimateBuyValue(\n    uint _currencyValue\n  ) public view\n    returns (uint)\n  {\n    if(_currencyValue < minInvestment)\n    {\n      return 0;\n    }\n\n    /// Calculate the tokenValue for this investment\n    uint tokenValue;\n    if(state == STATE_INIT)\n    {\n      uint currencyValue = _currencyValue;\n      uint _totalSupply = totalSupply();\n      // (buy_slope*init_goal)*(init_goal+init_reserve-total_supply)/2\n      // n/d: buy_slope (MAX_BEFORE_SQUARE / MAX_BEFORE_SQUARE)\n      // g: init_goal (MAX_BEFORE_SQUARE/2)\n      // t: total_supply (MAX_BEFORE_SQUARE/2)\n      // r: init_reserve (MAX_BEFORE_SQUARE/2)\n      // source: ((n/d)*g)*(g+r-t)/2\n      // impl: (g n (g + r - t))/(2 d)\n      uint max = BigDiv.bigDiv2x1(\n        initGoal * buySlopeNum,\n        initGoal + initReserve - _totalSupply,\n        2 * buySlopeDen\n      );\n      if(currencyValue > max)\n      {\n        currencyValue = max;\n      }\n      // Math: worst case\n      // MAX * 2 * MAX_BEFORE_SQUARE\n      // / MAX_BEFORE_SQUARE * MAX_BEFORE_SQUARE\n      tokenValue = BigDiv.bigDiv2x1(\n        currencyValue,\n        2 * buySlopeDen,\n        initGoal * buySlopeNum\n      );\n\n      if(currencyValue != _currencyValue)\n      {\n        currencyValue = _currencyValue - max;\n        // ((2*next_amount/buy_slope)+init_goal^2)^(1/2)-init_goal\n        // a: next_amount | currencyValue\n        // n/d: buy_slope (MAX_BEFORE_SQUARE / MAX_BEFORE_SQUARE)\n        // g: init_goal (MAX_BEFORE_SQUARE/2)\n        // r: init_reserve (MAX_BEFORE_SQUARE/2)\n        // sqrt(((2*a/(n/d))+g^2)-g\n        // sqrt((2 d a + n g^2)/n) - g\n\n        // currencyValue == 2 d a\n        uint temp = 2 * buySlopeDen;\n        currencyValue = temp.mul(currencyValue);\n\n        // temp == g^2\n        temp = initGoal;\n        temp *= temp;\n\n        // temp == n g^2\n        temp = temp.mul(buySlopeNum);\n\n        // temp == (2 d a) + n g^2\n        temp = currencyValue.add(temp);\n\n        // temp == (2 d a + n g^2)/n\n        temp /= buySlopeNum;\n\n        // temp == sqrt((2 d a + n g^2)/n)\n        temp = temp.sqrt();\n\n        // temp == sqrt((2 d a + n g^2)/n) - g\n        temp -= initGoal;\n\n        tokenValue = tokenValue.add(temp);\n      }\n    }\n    else if(state == STATE_RUN)\n    {\n      // initReserve is reduced on sell as necessary to ensure that this line will not overflow\n      uint supply = totalSupply() + burnedSupply - initReserve;\n      // Math: worst case\n      // MAX * 2 * MAX_BEFORE_SQUARE\n      // / MAX_BEFORE_SQUARE\n      tokenValue = BigDiv.bigDiv2x1(\n        _currencyValue,\n        2 * buySlopeDen,\n        buySlopeNum\n      );\n\n      // Math: worst case MAX + (MAX_BEFORE_SQUARE * MAX_BEFORE_SQUARE)\n      tokenValue = tokenValue.add(supply * supply);\n      tokenValue = tokenValue.sqrt();\n\n      // Math: small chance of underflow due to possible rounding in sqrt\n      tokenValue = tokenValue.sub(supply);\n    }\n    else\n    {\n      // invalid state\n      return 0;\n    }\n\n    return tokenValue;\n  }\n\n  /// @notice Purchase COT tokens with the given amount of currency.\n  /// @param _to The account to receive the COT tokens from this purchase.\n  /// @param _currencyValue How much currency to spend in order to buy COT.\n  /// @param _minTokensBought Buy at least this many COT tokens or the transaction reverts.\n  /// @dev _minTokensBought is necessary as the price will change if some elses transaction mines after\n  /// yours was submitted.\n  function buy(\n    address _to,\n    uint _currencyValue,\n    uint _minTokensBought\n  ) public payable\n  {\n    require(_to != address(0), \"INVALID_ADDRESS\");\n    require(_minTokensBought > 0, \"MUST_BUY_AT_LEAST_1\");\n\n    // Calculate the tokenValue for this investment\n    uint tokenValue = estimateBuyValue(_currencyValue);\n    require(tokenValue >= _minTokensBought, \"PRICE_SLIPPAGE\");\n\n    emit Buy(msg.sender, _to, _currencyValue, tokenValue);\n\n    _collectInvestment(_currencyValue, msg.value, false);\n\n    // Update state, initInvestors, and distribute the investment when appropriate\n    if(state == STATE_INIT)\n    {\n      // Math worst case: MAX_BEFORE_SQUARE\n      initInvestors[_to] += tokenValue;\n      // Math worst case:\n      // MAX_BEFORE_SQUARE + MAX_BEFORE_SQUARE\n      if(totalSupply() + tokenValue - initReserve >= initGoal)\n      {\n        emit StateChange(state, STATE_RUN);\n        state = STATE_RUN;\n        // Math worst case:\n        // MAX_BEFORE_SQUARE * MAX_BEFORE_SQUARE * MAX_BEFORE_SQUARE/2\n        // / MAX_BEFORE_SQUARE * 2\n        uint beneficiaryContribution = BigDiv.bigDiv2x1(\n          initInvestors[beneficiary],\n          buySlopeNum * initGoal,\n          buySlopeDen * 2\n        );\n        _distributeInvestment(buybackReserve().sub(beneficiaryContribution));\n      }\n    }\n    else // implied: if(state == STATE_RUN)\n    {\n      if(_to != beneficiary)\n      {\n        _distributeInvestment(_currencyValue);\n      }\n    }\n\n    _mint(_to, tokenValue);\n\n    if(state == STATE_RUN && msg.sender == beneficiary && _to == beneficiary && autoBurn)\n    {\n      // must mint before this call\n      _burn(beneficiary, tokenValue, false);\n    }\n  }\n\n  /// Sell\n\n  function estimateSellValue(\n    uint _quantityToSell\n  ) public view\n    returns(uint)\n  {\n    uint reserve = buybackReserve();\n\n    // Calculate currencyValue for this sale\n    uint currencyValue;\n    if(state == STATE_RUN)\n    {\n      uint supply = totalSupply() + burnedSupply;\n\n      // buyback_reserve = r\n      // total_supply = t\n      // burnt_supply = b\n      // amount = a\n      // source: (t+b)*a*(2*r)/((t+b)^2)-(((2*r)/((t+b)^2)*a^2)/2)+((2*r)/((t+b)^2)*a*b^2)/(2*(t))\n      // imp: (a b^2 r)/(t (b + t)^2) + (2 a r)/(b + t) - (a^2 r)/(b + t)^2\n\n      // Math: burnedSupply is capped in COT such that the square will never overflow\n      // Math worst case:\n      // MAX * MAX_BEFORE_SQUARE * MAX_BEFORE_SQUARE/2 * MAX_BEFORE_SQUARE/2\n      // / MAX_BEFORE_SQUARE/2 * MAX_BEFORE_SQUARE/2 * MAX_BEFORE_SQUARE/2\n      currencyValue = BigDiv.bigDiv2x2(\n        _quantityToSell.mul(reserve),\n        burnedSupply * burnedSupply,\n        totalSupply(), supply * supply\n      );\n      // Math: worst case currencyValue is MAX_BEFORE_SQUARE (max reserve, 1 supply)\n\n      // Math worst case:\n      // MAX * 2 * MAX_BEFORE_SQUARE\n      uint temp = _quantityToSell.mul(2 * reserve);\n      temp /= supply;\n      // Math: worst-case temp is MAX_BEFORE_SQUARE (max reserve, 1 supply)\n\n      // Math: considering the worst-case for currencyValue and temp, this can never overflow\n      currencyValue += temp;\n\n      // Math: worst case\n      // MAX * MAX * MAX_BEFORE_SQUARE\n      // / MAX_BEFORE_SQUARE/2 * MAX_BEFORE_SQUARE/2\n      currencyValue -= BigDiv.bigDiv2x1RoundUp(\n        _quantityToSell.mul(_quantityToSell),\n        reserve,\n        supply * supply\n      );\n    }\n    else if(state == STATE_CLOSE)\n    {\n      // Math worst case\n      // MAX * MAX_BEFORE_SQUARE\n      currencyValue = _quantityToSell.mul(reserve);\n      currencyValue /= totalSupply();\n    }\n    else\n    {\n      // STATE_INIT or STATE_CANCEL\n      // Math worst case:\n      // MAX * MAX_BEFORE_SQUARE\n      currencyValue = _quantityToSell.mul(reserve);\n      // Math: COT blocks initReserve from being burned unless we reach the RUN state which prevents an underflow\n      currencyValue /= totalSupply() - initReserve;\n    }\n\n    return currencyValue;\n  }\n\n  /// @notice Sell COT tokens for at least the given amount of currency.\n  /// @param _to The account to receive the currency from this sale.\n  /// @param _quantityToSell How many COT tokens to sell for currency value.\n  /// @param _minCurrencyReturned Get at least this many currency tokens or the transaction reverts.\n  /// @dev _minCurrencyReturned is necessary as the price will change if some elses transaction mines after\n  /// yours was submitted.\n  function sell(\n    address payable _to,\n    uint _quantityToSell,\n    uint _minCurrencyReturned\n  ) public\n  {\n    require(msg.sender != beneficiary || state >= STATE_CLOSE, \"BENEFICIARY_ONLY_SELL_IN_CLOSE_OR_CANCEL\");\n    require(_minCurrencyReturned > 0, \"MUST_SELL_AT_LEAST_1\");\n\n    uint currencyValue = estimateSellValue(_quantityToSell);\n    require(currencyValue >= _minCurrencyReturned, \"PRICE_SLIPPAGE\");\n\n    if(state == STATE_INIT || state == STATE_CANCEL)\n    {\n      initInvestors[msg.sender] = initInvestors[msg.sender].sub(_quantityToSell);\n    }\n\n    _burn(msg.sender, _quantityToSell, true);\n    uint supply = totalSupply() + burnedSupply;\n    if(supply < initReserve)\n    {\n      initReserve = supply;\n    }\n\n    _transferCurrency(_to, currencyValue);\n    emit Sell(msg.sender, _to, currencyValue, _quantityToSell);\n  }\n\n  /// Pay\n\n  function estimatePayValue(\n    uint _currencyValue\n  ) public view\n    returns (uint)\n  {\n    // buy_slope = n/d\n    // revenue_commitment = c/g\n    // sqrt(\n    //  (2 a c d)\n    //  /\n    //  (g n)\n    //  + s^2\n    // ) - s\n\n    uint supply = totalSupply() + burnedSupply;\n\n    // Math: worst case\n    // MAX * 2 * 10000 * MAX_BEFORE_SQUARE\n    // / 10000 * MAX_BEFORE_SQUARE\n    uint tokenValue = BigDiv.bigDiv2x1(\n      _currencyValue.mul(2 * revenueCommitmentBasisPoints),\n      buySlopeDen,\n      BASIS_POINTS_DEN * buySlopeNum\n    );\n\n    tokenValue = tokenValue.add(supply * supply);\n    tokenValue = tokenValue.sqrt();\n\n    if(tokenValue > supply)\n    {\n      tokenValue -= supply;\n    }\n    else\n    {\n      tokenValue = 0;\n    }\n\n    return tokenValue;\n  }\n\n  /// @dev Pay the organization on-chain.\n  /// @param _to The account which receives tokens for the contribution.\n  /// @param _currencyValue How much currency which was paid.\n  function _pay(\n    address _to,\n    uint _currencyValue\n  ) private\n  {\n    require(_currencyValue > 0, \"MISSING_CURRENCY\");\n    require(state == STATE_RUN, \"INVALID_STATE\");\n\n    // Send a portion of the funds to the beneficiary, the rest is added to the buybackReserve\n    // Math: if _currencyValue is < (2^256 - 1) / 10000 this will not overflow\n    uint reserve = _currencyValue.mul(investmentReserveBasisPoints);\n    reserve /= BASIS_POINTS_DEN;\n\n    uint tokenValue = estimatePayValue(_currencyValue);\n\n    // Update the to address to the beneficiary if the currency value would fail\n    address to = _to;\n    if(to == address(0))\n    {\n      to = beneficiary;\n    }\n    else if(_detectTransferRestriction(address(0), _to, tokenValue) != 0)\n    {\n      to = beneficiary;\n    }\n\n    // Math: this will never underflow since investmentReserveBasisPoints is capped to BASIS_POINTS_DEN\n    _transferCurrency(beneficiary, _currencyValue - reserve);\n\n    // Distribute tokens\n    if(tokenValue > 0)\n    {\n      _mint(to, tokenValue);\n      if(to == beneficiary && autoBurn)\n      {\n        // must mint before this call\n        _burn(beneficiary, tokenValue, false);\n      }\n    }\n\n    emit Pay(msg.sender, _to, _currencyValue, tokenValue);\n  }\n\n  /// @dev Pay the organization on-chain.\n  /// @param _to The account which receives tokens for the contribution. If this address\n  /// is not authorized to receive tokens then they will be sent to the beneficiary account instead.\n  /// @param _currencyValue How much currency which was paid.\n  function pay(\n    address _to,\n    uint _currencyValue\n  ) public payable\n  {\n    _collectInvestment(_currencyValue, msg.value, false);\n    _pay(_to, _currencyValue);\n  }\n\n  /// @notice Pay the organization on-chain without minting any tokens.\n  /// @dev This allows you to add funds directly to the buybackReserve.\n  function () external payable\n  {\n    require(address(currency) == address(0), \"ONLY_FOR_CURRENCY_ETH\");\n  }\n  \n  /// Close\n\n  function estimateExitFee(\n    uint _msgValue\n  ) public view\n    returns(uint)\n  {\n    uint exitFee;\n\n    if(state == STATE_RUN)\n    {\n      uint reserve = buybackReserve();\n      reserve = reserve.sub(_msgValue);\n\n      // Source: t*(t+b)*(n/d)-r\n      // Implementation: (b n t)/d + (n t^2)/d - r\n\n      uint _totalSupply = totalSupply();\n\n      // Math worst case:\n      // MAX_BEFORE_SQUARE * MAX_BEFORE_SQUARE/2 * MAX_BEFORE_SQUARE\n      exitFee = BigDiv.bigDiv2x1(\n        _totalSupply,\n        burnedSupply * buySlopeNum,\n        buySlopeDen\n      );\n      // Math worst case:\n      // MAX_BEFORE_SQUARE * MAX_BEFORE_SQUARE * MAX_BEFORE_SQUARE\n      exitFee += BigDiv.bigDiv2x1(\n        _totalSupply,\n        buySlopeNum * _totalSupply,\n        buySlopeDen\n      );\n      // Math: this if condition avoids a potential overflow\n      if(exitFee <= reserve)\n      {\n        exitFee = 0;\n      }\n      else\n      {\n        exitFee -= reserve;\n      }\n    }\n\n    return exitFee;\n  }\n\n  /// @notice Called by the beneficiary account to STATE_CLOSE or STATE_CANCEL the c-org,\n  /// preventing any more tokens from being minted.\n  /// @dev Requires an `exitFee` to be paid.  If the currency is ETH, include a little more than\n  /// what appears to be required and any remainder will be returned to your account.  This is\n  /// because another user may have a transaction mined which changes the exitFee required.\n  /// For other `currency` types, the beneficiary account will be billed the exact amount required.\n  function close() public payable\n  {\n    require(msg.sender == beneficiary, \"BENEFICIARY_ONLY\");\n\n    uint exitFee = 0;\n\n    if(state == STATE_INIT)\n    {\n      // Allow the org to cancel anytime if the initGoal was not reached.\n      emit StateChange(state, STATE_CANCEL);\n      state = STATE_CANCEL;\n    }\n    else if(state == STATE_RUN)\n    {\n      // Collect the exitFee and close the c-org.\n      require(openUntilAtLeast <= block.timestamp, \"TOO_EARLY\");\n\n      exitFee = estimateExitFee(msg.value);\n\n      emit StateChange(state, STATE_CLOSE);\n      state = STATE_CLOSE;\n\n      _collectInvestment(exitFee, msg.value, true);\n    }\n    else\n    {\n      revert(\"INVALID_STATE\");\n    }\n\n    emit Close(exitFee);\n  }\n\n  // --- Approve by signature ---\n  // Original source: https://etherscan.io/address/0x6b175474e89094c44da98b954eedeac495271d0f#code\n  function permit(\n    address holder,\n    address spender,\n    uint256 nonce,\n    uint256 expiry,\n    bool allowed,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external\n  {\n    bytes32 digest = keccak256(\n      abi.encodePacked(\n        \"\\x19\\x01\",\n        DOMAIN_SEPARATOR,\n        keccak256(\n          abi.encode(PERMIT_TYPEHASH,\n                    holder,\n                    spender,\n                    nonce,\n                    expiry,\n                    allowed\n          )\n        )\n      )\n    );\n\n    require(holder != address(0), \"DAT/invalid-address-0\");\n    require(holder == ecrecover(digest, v, r, s), \"DAT/invalid-permit\");\n    require(expiry == 0 || now <= expiry, \"DAT/permit-expired\");\n    require(nonce == nonces[holder]++, \"DAT/invalid-nonce\");\n    uint wad = allowed ? uint(-1) : 0;\n    _approve(holder, spender, wad);\n  }\n}\n"
    },
    "contracts/dxd/interfaces/IWhitelist.sol": {
      "content": "pragma solidity 0.5.17;\n\n\n/**\n * Source: https://raw.githubusercontent.com/simple-restricted-token/reference-implementation/master/contracts/token/ERC1404/ERC1404.sol\n * With ERC-20 APIs removed (will be implemented as a separate contract).\n * And adding authorizeTransfer.\n */\ninterface IWhitelist\n{\n  /**\n   * @notice Detects if a transfer will be reverted and if so returns an appropriate reference code\n   * @param from Sending address\n   * @param to Receiving address\n   * @param value Amount of tokens being transferred\n   * @return Code by which to reference message for rejection reasoning\n   * @dev Overwrite with your custom transfer restriction logic\n   */\n  function detectTransferRestriction(\n    address from,\n    address to,\n    uint value\n  ) external view\n    returns (uint8);\n\n  /**\n   * @notice Returns a human-readable message for a given restriction code\n   * @param restrictionCode Identifier for looking up a message\n   * @return Text showing the restriction's reasoning\n   * @dev Overwrite with your custom message and restrictionCode handling\n   */\n  function messageForTransferRestriction(\n    uint8 restrictionCode\n  ) external pure\n    returns (string memory);\n\n  /**\n   * @notice Called by the DAT contract before a transfer occurs.\n   * @dev This call will revert when the transfer is not authorized.\n   * This is a mutable call to allow additional data to be recorded,\n   * such as when the user aquired their tokens.\n   */\n  function authorizeTransfer(\n    address _from,\n    address _to,\n    uint _value,\n    bool _isSell\n  ) external;\n}"
    },
    "contracts/dxd/math/BigDiv.sol": {
      "content": "pragma solidity ^0.5.0;\n\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\n\n/**\n * @title Reduces the size of terms before multiplication, to avoid an overflow, and then\n * restores the proper size after division.\n * @notice This effectively allows us to overflow values in the numerator and/or denominator\n * of a fraction, so long as the end result does not overflow as well.\n * @dev Results may be off by 1 + 0.000001% for 2x1 calls and 2 + 0.00001% for 2x2 calls.\n * Do not use if your contract expects very small result values to be accurate.\n */\nlibrary BigDiv\n{\n  using SafeMath for uint256;\n\n  /// @notice The max possible value\n  uint256 private constant MAX_UINT = 2**256 - 1;\n\n  /// @notice When multiplying 2 terms <= this value the result won't overflow\n  uint256 private constant MAX_BEFORE_SQUARE = 2**128 - 1;\n\n  /// @notice The max error target is off by 1 plus up to 0.000001% error\n  /// for bigDiv2x1 and that `* 2` for bigDiv2x2\n  uint256 private constant MAX_ERROR = 100000000;\n\n  /// @notice A larger error threshold to use when multiple rounding errors may apply\n  uint256 private constant MAX_ERROR_BEFORE_DIV = MAX_ERROR * 2;\n\n  /**\n   * @notice Returns the approx result of `a * b / d` so long as the result is <= MAX_UINT\n   * @param _numA the first numerator term\n   * @param _numB the second numerator term\n   * @param _den the denominator\n   * @return the approx result with up to off by 1 + MAX_ERROR, rounding down if needed\n   */\n  function bigDiv2x1(\n    uint256 _numA,\n    uint256 _numB,\n    uint256 _den\n  ) internal pure\n    returns(uint256)\n  {\n    if(_numA == 0 || _numB == 0)\n    {\n      // would div by 0 or underflow if we don't special case 0\n      return 0;\n    }\n\n    uint256 value;\n\n    if(MAX_UINT / _numA >= _numB)\n    {\n      // a*b does not overflow, return exact math\n      value = _numA * _numB;\n      value /= _den;\n      return value;\n    }\n\n    // Sort numerators\n    uint256 numMax = _numB;\n    uint256 numMin = _numA;\n    if(_numA > _numB)\n    {\n      numMax = _numA;\n      numMin = _numB;\n    }\n\n    value = numMax / _den;\n    if(value > MAX_ERROR)\n    {\n      // _den is small enough to be MAX_ERROR or better w/o a factor\n      value = value.mul(numMin);\n      return value;\n    }\n\n    // formula = ((a / f) * b) / (d / f)\n    // factor >= a / sqrt(MAX) * (b / sqrt(MAX))\n    uint256 factor = numMin - 1;\n    factor /= MAX_BEFORE_SQUARE;\n    factor += 1;\n    uint256 temp = numMax - 1;\n    temp /= MAX_BEFORE_SQUARE;\n    temp += 1;\n    if(MAX_UINT / factor >= temp)\n    {\n      factor *= temp;\n      value = numMax / factor;\n      if(value > MAX_ERROR_BEFORE_DIV)\n      {\n        value = value.mul(numMin);\n        temp = _den - 1;\n        temp /= factor;\n        temp = temp.add(1);\n        value /= temp;\n        return value;\n      }\n    }\n\n    // formula: (a / (d / f)) * (b / f)\n    // factor: b / sqrt(MAX)\n    factor = numMin - 1;\n    factor /= MAX_BEFORE_SQUARE;\n    factor += 1;\n    value = numMin / factor;\n    temp = _den - 1;\n    temp /= factor;\n    temp += 1;\n    temp = numMax / temp;\n    value = value.mul(temp);\n    return value;\n  }\n\n  /**\n   * @notice Returns the approx result of `a * b / d` so long as the result is <= MAX_UINT\n   * @param _numA the first numerator term\n   * @param _numB the second numerator term\n   * @param _den the denominator\n   * @return the approx result with up to off by 1 + MAX_ERROR, rounding down if needed\n   * @dev roundUp is implemented by first rounding down and then adding the max error to the result\n   */\n  function bigDiv2x1RoundUp(\n    uint256 _numA,\n    uint256 _numB,\n    uint256 _den\n  ) internal pure\n    returns(uint256)\n  {\n    // first get the rounded down result\n    uint256 value = bigDiv2x1(_numA, _numB, _den);\n\n    if(value == 0)\n    {\n      // when the value rounds down to 0, assume up to an off by 1 error\n      return 1;\n    }\n\n    // round down has a max error of MAX_ERROR, add that to the result\n    // for a round up error of <= MAX_ERROR\n    uint256 temp = value - 1;\n    temp /= MAX_ERROR;\n    temp += 1;\n    if(MAX_UINT - value < temp)\n    {\n      // value + error would overflow, return MAX\n      return MAX_UINT;\n    }\n\n    value += temp;\n\n    return value;\n  }\n\n  /**\n   * @notice Returns the approx result of `a * b / (c * d)` so long as the result is <= MAX_UINT\n   * @param _numA the first numerator term\n   * @param _numB the second numerator term\n   * @param _denA the first denominator term\n   * @param _denB the second denominator term\n   * @return the approx result with up to off by 2 + MAX_ERROR*10 error, rounding down if needed\n   * @dev this uses bigDiv2x1 and adds additional rounding error so the max error of this\n   * formula is larger\n   */\n  function bigDiv2x2(\n    uint256 _numA,\n    uint256 _numB,\n    uint256 _denA,\n    uint256 _denB\n  ) internal pure\n    returns (uint256)\n  {\n    if(MAX_UINT / _denA >= _denB)\n    {\n      // denA*denB does not overflow, use bigDiv2x1 instead\n      return bigDiv2x1(_numA, _numB, _denA * _denB);\n    }\n\n    if(_numA == 0 || _numB == 0)\n    {\n      // would div by 0 or underflow if we don't special case 0\n      return 0;\n    }\n\n    // Sort denominators\n    uint256 denMax = _denB;\n    uint256 denMin = _denA;\n    if(_denA > _denB)\n    {\n      denMax = _denA;\n      denMin = _denB;\n    }\n\n    uint256 value;\n\n    if(MAX_UINT / _numA >= _numB)\n    {\n      // a*b does not overflow, use `a / d / c`\n      value = _numA * _numB;\n      value /= denMin;\n      value /= denMax;\n      return value;\n    }\n\n    // `ab / cd` where both `ab` and `cd` would overflow\n\n    // Sort numerators\n    uint256 numMax = _numB;\n    uint256 numMin = _numA;\n    if(_numA > _numB)\n    {\n      numMax = _numA;\n      numMin = _numB;\n    }\n\n    // formula = (a/d) * b / c\n    uint256 temp = numMax / denMin;\n    if(temp > MAX_ERROR_BEFORE_DIV)\n    {\n      return bigDiv2x1(temp, numMin, denMax);\n    }\n\n    // formula: ((a/f) * b) / d then either * f / c or / c * f\n    // factor >= a / sqrt(MAX) * (b / sqrt(MAX))\n    uint256 factor = numMin - 1;\n    factor /= MAX_BEFORE_SQUARE;\n    factor += 1;\n    temp = numMax - 1;\n    temp /= MAX_BEFORE_SQUARE;\n    temp += 1;\n    if(MAX_UINT / factor >= temp)\n    {\n      factor *= temp;\n\n      value = numMax / factor;\n      if(value > MAX_ERROR_BEFORE_DIV)\n      {\n        value = value.mul(numMin);\n        value /= denMin;\n        if(value > 0 && MAX_UINT / value >= factor)\n        {\n          value *= factor;\n          value /= denMax;\n          return value;\n        }\n      }\n    }\n\n    // formula: (a/f) * b / ((c*d)/f)\n    // factor >= c / sqrt(MAX) * (d / sqrt(MAX))\n    factor = denMin;\n    factor /= MAX_BEFORE_SQUARE;\n    temp = denMax;\n    // + 1 here prevents overflow of factor*temp\n    temp /= MAX_BEFORE_SQUARE + 1;\n    factor *= temp;\n    return bigDiv2x1(numMax / factor, numMin, MAX_UINT);\n  }\n}\n"
    },
    "contracts/dxd/math/Sqrt.sol": {
      "content": "pragma solidity ^0.5.0;\n\n\n/**\n * @title Calculates the square root of a given value.\n * @dev Results may be off by 1.\n */\nlibrary Sqrt\n{\n  /// @notice The max possible value\n  uint256 private constant MAX_UINT = 2**256 - 1;\n\n  // Source: https://github.com/ethereum/dapp-bin/pull/50\n  function sqrt(\n    uint x\n  ) internal pure\n    returns (uint y)\n  {\n    if (x == 0)\n    {\n      return 0;\n    }\n    else if (x <= 3)\n    {\n      return 1;\n    }\n    else if (x == MAX_UINT)\n    {\n      // Without this we fail on x + 1 below\n      return 2**128 - 1;\n    }\n\n    uint z = (x + 1) / 2;\n    y = x;\n    while (z < y)\n    {\n      y = z;\n      z = (x / z + z) / 2;\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol": {
      "content": "pragma solidity ^0.5.5;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following \n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/SafeERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Detailed.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"./IERC20.sol\";\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed is Initializable, IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    uint256[50] private ______gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Initializable, Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n\n    uint256[50] private ______gap;\n}\n"
    },
    "@openzeppelin/upgrades/contracts/Initializable.sol": {
      "content": "pragma solidity >=0.4.24 <0.7.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context is Initializable {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/dxd/utils/DecentralizedAutonomousTrustUpgrade.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"../DecentralizedAutonomousTrust.sol\";\n\ncontract DecentralizedAutonomousTrustUpgrade\n  is DecentralizedAutonomousTrust\n{\n    \n    uint256 public newNumber;\n\n    function saveNumber(uint _newNumber) public {\n      require(control == msg.sender);\n      newNumber = _newNumber;\n    }\n  \n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/access/roles/MinterRole.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n\nimport \"../../GSN/Context.sol\";\nimport \"../Roles.sol\";\n\ncontract MinterRole is Initializable, Context {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    function initialize(address sender) public initializer {\n        if (!isMinter(sender)) {\n            _addMinter(sender);\n        }\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(_msgSender()), \"MinterRole: caller does not have the Minter role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(_msgSender());\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n\n    uint256[50] private ______gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/access/Roles.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/ownership/Ownable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n\nimport \"../GSN/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Initializable, Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function initialize(address sender) public initializer {\n        _owner = sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    uint256[50] private ______gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/drafts/TokenVesting.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"../token/ERC20/SafeERC20.sol\";\nimport \"../ownership/Ownable.sol\";\nimport \"../math/SafeMath.sol\";\n\n/**\n * @title TokenVesting\n * @dev A token holder contract that can release its token balance gradually like a\n * typical vesting scheme, with a cliff and vesting period. Optionally revocable by the\n * owner.\n */\ncontract TokenVesting is Initializable, Ownable {\n    // The vesting schedule is time-based (i.e. using block timestamps as opposed to e.g. block numbers), and is\n    // therefore sensitive to timestamp manipulation (which is something miners can do, to a certain degree). Therefore,\n    // it is recommended to avoid using short time durations (less than a minute). Typical vesting schemes, with a\n    // cliff period of a year and a duration of four years, are safe to use.\n    // solhint-disable not-rely-on-time\n\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    event TokensReleased(address token, uint256 amount);\n    event TokenVestingRevoked(address token);\n\n    // beneficiary of tokens after they are released\n    address private _beneficiary;\n\n    // Durations and timestamps are expressed in UNIX time, the same units as block.timestamp.\n    uint256 private _cliff;\n    uint256 private _start;\n    uint256 private _duration;\n\n    bool private _revocable;\n\n    mapping (address => uint256) private _released;\n    mapping (address => bool) private _revoked;\n\n    /**\n     * @dev Creates a vesting contract that vests its balance of any ERC20 token to the\n     * beneficiary, gradually in a linear fashion until start + duration. By then all\n     * of the balance will have vested.\n     * @param beneficiary address of the beneficiary to whom vested tokens are transferred\n     * @param cliffDuration duration in seconds of the cliff in which tokens will begin to vest\n     * @param start the time (as Unix time) at which point vesting starts\n     * @param duration duration in seconds of the period in which the tokens will vest\n     * @param revocable whether the vesting is revocable or not\n     */\n    function initialize(address beneficiary, uint256 start, uint256 cliffDuration, uint256 duration, bool revocable, address sender) public initializer {\n        Ownable.initialize(sender);\n\n        require(beneficiary != address(0), \"TokenVesting: beneficiary is the zero address\");\n        // solhint-disable-next-line max-line-length\n        require(cliffDuration <= duration, \"TokenVesting: cliff is longer than duration\");\n        require(duration > 0, \"TokenVesting: duration is 0\");\n        // solhint-disable-next-line max-line-length\n        require(start.add(duration) > block.timestamp, \"TokenVesting: final time is before current time\");\n\n        _beneficiary = beneficiary;\n        _revocable = revocable;\n        _duration = duration;\n        _cliff = start.add(cliffDuration);\n        _start = start;\n    }\n\n    /**\n     * @return the beneficiary of the tokens.\n     */\n    function beneficiary() public view returns (address) {\n        return _beneficiary;\n    }\n\n    /**\n     * @return the cliff time of the token vesting.\n     */\n    function cliff() public view returns (uint256) {\n        return _cliff;\n    }\n\n    /**\n     * @return the start time of the token vesting.\n     */\n    function start() public view returns (uint256) {\n        return _start;\n    }\n\n    /**\n     * @return the duration of the token vesting.\n     */\n    function duration() public view returns (uint256) {\n        return _duration;\n    }\n\n    /**\n     * @return true if the vesting is revocable.\n     */\n    function revocable() public view returns (bool) {\n        return _revocable;\n    }\n\n    /**\n     * @return the amount of the token released.\n     */\n    function released(address token) public view returns (uint256) {\n        return _released[token];\n    }\n\n    /**\n     * @return true if the token is revoked.\n     */\n    function revoked(address token) public view returns (bool) {\n        return _revoked[token];\n    }\n\n    /**\n     * @notice Transfers vested tokens to beneficiary.\n     * @param token ERC20 token which is being vested\n     */\n    function release(IERC20 token) public {\n        uint256 unreleased = _releasableAmount(token);\n\n        require(unreleased > 0, \"TokenVesting: no tokens are due\");\n\n        _released[address(token)] = _released[address(token)].add(unreleased);\n\n        token.safeTransfer(_beneficiary, unreleased);\n\n        emit TokensReleased(address(token), unreleased);\n    }\n\n    /**\n     * @notice Allows the owner to revoke the vesting. Tokens already vested\n     * remain in the contract, the rest are returned to the owner.\n     * @param token ERC20 token which is being vested\n     */\n    function revoke(IERC20 token) public onlyOwner {\n        require(_revocable, \"TokenVesting: cannot revoke\");\n        require(!_revoked[address(token)], \"TokenVesting: token already revoked\");\n\n        uint256 balance = token.balanceOf(address(this));\n\n        uint256 unreleased = _releasableAmount(token);\n        uint256 refund = balance.sub(unreleased);\n\n        _revoked[address(token)] = true;\n\n        token.safeTransfer(owner(), refund);\n\n        emit TokenVestingRevoked(address(token));\n    }\n\n    /**\n     * @dev Calculates the amount that has already vested but hasn't been released yet.\n     * @param token ERC20 token which is being vested\n     */\n    function _releasableAmount(IERC20 token) private view returns (uint256) {\n        return _vestedAmount(token).sub(_released[address(token)]);\n    }\n\n    /**\n     * @dev Calculates the amount that has already vested.\n     * @param token ERC20 token which is being vested\n     */\n    function _vestedAmount(IERC20 token) private view returns (uint256) {\n        uint256 currentBalance = token.balanceOf(address(this));\n        uint256 totalBalance = currentBalance.add(_released[address(token)]);\n\n        if (block.timestamp < _cliff) {\n            return 0;\n        } else if (block.timestamp >= _start.add(_duration) || _revoked[address(token)]) {\n            return totalBalance;\n        } else {\n            return totalBalance.mul(block.timestamp.sub(_start)).div(_duration);\n        }\n    }\n\n    uint256[50] private ______gap;\n}\n"
    },
    "contracts/dxd/Dependencies.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Mintable.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/drafts/TokenVesting.sol\";\nimport \"@openzeppelin/upgrades/contracts/upgradeability/AdminUpgradeabilityProxy.sol\";\nimport \"@openzeppelin/upgrades/contracts/upgradeability/ProxyAdmin.sol\";\n\n/**\n * This creates the artifacts allowing us to use these 3rd party contracts directly\n */\ncontract Dependencies {\n    constructor() internal {}\n}\n"
    },
    "@openzeppelin/upgrades/contracts/upgradeability/AdminUpgradeabilityProxy.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport './BaseAdminUpgradeabilityProxy.sol';\n\n/**\n * @title AdminUpgradeabilityProxy\n * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for \n * initializing the implementation, admin, and init data.\n */\ncontract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy {\n  /**\n   * Contract constructor.\n   * @param _logic address of the initial implementation.\n   * @param _admin Address of the proxy administrator.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  constructor(address _logic, address _admin, bytes memory _data) UpgradeabilityProxy(_logic, _data) public payable {\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n    _setAdmin(_admin);\n  }\n}\n"
    },
    "@openzeppelin/upgrades/contracts/upgradeability/ProxyAdmin.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../ownership/Ownable.sol\";\nimport \"./AdminUpgradeabilityProxy.sol\";\n\n/**\n * @title ProxyAdmin\n * @dev This contract is the admin of a proxy, and is in charge\n * of upgrading it as well as transferring it to another admin.\n */\ncontract ProxyAdmin is OpenZeppelinUpgradesOwnable {\n  \n  /**\n   * @dev Returns the current implementation of a proxy.\n   * This is needed because only the proxy admin can query it.\n   * @return The address of the current implementation of the proxy.\n   */\n  function getProxyImplementation(AdminUpgradeabilityProxy proxy) public view returns (address) {\n    // We need to manually run the static call since the getter cannot be flagged as view\n    // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n    (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n    require(success);\n    return abi.decode(returndata, (address));\n  }\n\n  /**\n   * @dev Returns the admin of a proxy. Only the admin can query it.\n   * @return The address of the current admin of the proxy.\n   */\n  function getProxyAdmin(AdminUpgradeabilityProxy proxy) public view returns (address) {\n    // We need to manually run the static call since the getter cannot be flagged as view\n    // bytes4(keccak256(\"admin()\")) == 0xf851a440\n    (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n    require(success);\n    return abi.decode(returndata, (address));\n  }\n\n  /**\n   * @dev Changes the admin of a proxy.\n   * @param proxy Proxy to change admin.\n   * @param newAdmin Address to transfer proxy administration to.\n   */\n  function changeProxyAdmin(AdminUpgradeabilityProxy proxy, address newAdmin) public onlyOwner {\n    proxy.changeAdmin(newAdmin);\n  }\n\n  /**\n   * @dev Upgrades a proxy to the newest implementation of a contract.\n   * @param proxy Proxy to be upgraded.\n   * @param implementation the address of the Implementation.\n   */\n  function upgrade(AdminUpgradeabilityProxy proxy, address implementation) public onlyOwner {\n    proxy.upgradeTo(implementation);\n  }\n\n  /**\n   * @dev Upgrades a proxy to the newest implementation of a contract and forwards a function call to it.\n   * This is useful to initialize the proxied contract.\n   * @param proxy Proxy to be upgraded.\n   * @param implementation Address of the Implementation.\n   * @param data Data to send as msg.data in the low level call.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   */\n  function upgradeAndCall(AdminUpgradeabilityProxy proxy, address implementation, bytes memory data) payable public onlyOwner {\n    proxy.upgradeToAndCall.value(msg.value)(implementation, data);\n  }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Mintable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"./ERC20.sol\";\nimport \"../../access/roles/MinterRole.sol\";\n\n/**\n * @dev Extension of {ERC20} that adds a set of accounts with the {MinterRole},\n * which have permission to mint (create) new tokens as they see fit.\n *\n * At construction, the deployer of the contract is the only minter.\n */\ncontract ERC20Mintable is Initializable, ERC20, MinterRole {\n    function initialize(address sender) public initializer {\n        MinterRole.initialize(sender);\n    }\n\n    /**\n     * @dev See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the {MinterRole}.\n     */\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n\n    uint256[50] private ______gap;\n}\n"
    },
    "@openzeppelin/upgrades/contracts/upgradeability/BaseAdminUpgradeabilityProxy.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport './UpgradeabilityProxy.sol';\n\n/**\n * @title BaseAdminUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with an authorization\n * mechanism for administrative tasks.\n * All external functions in this contract must be guarded by the\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n * feature proposal that would enable this to be done automatically.\n */\ncontract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\n  /**\n   * @dev Emitted when the administration has been transferred.\n   * @param previousAdmin Address of the previous admin.\n   * @param newAdmin Address of the new admin.\n   */\n  event AdminChanged(address previousAdmin, address newAdmin);\n\n  /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n\n  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  /**\n   * @dev Modifier to check whether the `msg.sender` is the admin.\n   * If it is, it will run the function. Otherwise, it will delegate the call\n   * to the implementation.\n   */\n  modifier ifAdmin() {\n    if (msg.sender == _admin()) {\n      _;\n    } else {\n      _fallback();\n    }\n  }\n\n  /**\n   * @return The address of the proxy admin.\n   */\n  function admin() external ifAdmin returns (address) {\n    return _admin();\n  }\n\n  /**\n   * @return The address of the implementation.\n   */\n  function implementation() external ifAdmin returns (address) {\n    return _implementation();\n  }\n\n  /**\n   * @dev Changes the admin of the proxy.\n   * Only the current admin can call this function.\n   * @param newAdmin Address to transfer proxy administration to.\n   */\n  function changeAdmin(address newAdmin) external ifAdmin {\n    require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n    emit AdminChanged(_admin(), newAdmin);\n    _setAdmin(newAdmin);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy.\n   * Only the admin can call this function.\n   * @param newImplementation Address of the new implementation.\n   */\n  function upgradeTo(address newImplementation) external ifAdmin {\n    _upgradeTo(newImplementation);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy and call a function\n   * on the new implementation.\n   * This is useful to initialize the proxied contract.\n   * @param newImplementation Address of the new implementation.\n   * @param data Data to send as msg.data in the low level call.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   */\n  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {\n    _upgradeTo(newImplementation);\n    (bool success,) = newImplementation.delegatecall(data);\n    require(success);\n  }\n\n  /**\n   * @return The admin slot.\n   */\n  function _admin() internal view returns (address adm) {\n    bytes32 slot = ADMIN_SLOT;\n    assembly {\n      adm := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Sets the address of the proxy admin.\n   * @param newAdmin Address of the new proxy admin.\n   */\n  function _setAdmin(address newAdmin) internal {\n    bytes32 slot = ADMIN_SLOT;\n\n    assembly {\n      sstore(slot, newAdmin)\n    }\n  }\n\n  /**\n   * @dev Only fall back when the sender is not the admin.\n   */\n  function _willFallback() internal {\n    require(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\");\n    super._willFallback();\n  }\n}\n"
    },
    "@openzeppelin/upgrades/contracts/upgradeability/UpgradeabilityProxy.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport './BaseUpgradeabilityProxy.sol';\n\n/**\n * @title UpgradeabilityProxy\n * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing\n * implementation and init data.\n */\ncontract UpgradeabilityProxy is BaseUpgradeabilityProxy {\n  /**\n   * @dev Contract constructor.\n   * @param _logic Address of the initial implementation.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  constructor(address _logic, bytes memory _data) public payable {\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n    _setImplementation(_logic);\n    if(_data.length > 0) {\n      (bool success,) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }  \n}\n"
    },
    "@openzeppelin/upgrades/contracts/upgradeability/BaseUpgradeabilityProxy.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport './Proxy.sol';\nimport '../utils/Address.sol';\n\n/**\n * @title BaseUpgradeabilityProxy\n * @dev This contract implements a proxy that allows to change the\n * implementation address to which it will delegate.\n * Such a change is called an implementation upgrade.\n */\ncontract BaseUpgradeabilityProxy is Proxy {\n  /**\n   * @dev Emitted when the implementation is upgraded.\n   * @param implementation Address of the new implementation.\n   */\n  event Upgraded(address indexed implementation);\n\n  /**\n   * @dev Storage slot with the address of the current implementation.\n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /**\n   * @dev Returns the current implementation.\n   * @return Address of the current implementation\n   */\n  function _implementation() internal view returns (address impl) {\n    bytes32 slot = IMPLEMENTATION_SLOT;\n    assembly {\n      impl := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Upgrades the proxy to a new implementation.\n   * @param newImplementation Address of the new implementation.\n   */\n  function _upgradeTo(address newImplementation) internal {\n    _setImplementation(newImplementation);\n    emit Upgraded(newImplementation);\n  }\n\n  /**\n   * @dev Sets the implementation address of the proxy.\n   * @param newImplementation Address of the new implementation.\n   */\n  function _setImplementation(address newImplementation) internal {\n    require(OpenZeppelinUpgradesAddress.isContract(newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\n\n    bytes32 slot = IMPLEMENTATION_SLOT;\n\n    assembly {\n      sstore(slot, newImplementation)\n    }\n  }\n}\n"
    },
    "@openzeppelin/upgrades/contracts/upgradeability/Proxy.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title Proxy\n * @dev Implements delegation of calls to other contracts, with proper\n * forwarding of return values and bubbling of failures.\n * It defines a fallback function that delegates all calls to the address\n * returned by the abstract _implementation() internal function.\n */\ncontract Proxy {\n  /**\n   * @dev Fallback function.\n   * Implemented entirely in `_fallback`.\n   */\n  function () payable external {\n    _fallback();\n  }\n\n  /**\n   * @return The Address of the implementation.\n   */\n  function _implementation() internal view returns (address);\n\n  /**\n   * @dev Delegates execution to an implementation contract.\n   * This is a low level function that doesn't return to its internal call site.\n   * It will return to the external caller whatever the implementation returns.\n   * @param implementation Address to delegate.\n   */\n  function _delegate(address implementation) internal {\n    assembly {\n      // Copy msg.data. We take full control of memory in this inline assembly\n      // block because it will not return to Solidity code. We overwrite the\n      // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize)\n\n      // Call the implementation.\n      // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n\n      // Copy the returned data.\n      returndatacopy(0, 0, returndatasize)\n\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 { revert(0, returndatasize) }\n      default { return(0, returndatasize) }\n    }\n  }\n\n  /**\n   * @dev Function that is run as the first thing in the fallback function.\n   * Can be redefined in derived contracts to add functionality.\n   * Redefinitions must call super._willFallback().\n   */\n  function _willFallback() internal {\n  }\n\n  /**\n   * @dev fallback implementation.\n   * Extracted to enable manual triggering.\n   */\n  function _fallback() internal {\n    _willFallback();\n    _delegate(_implementation());\n  }\n}\n"
    },
    "@openzeppelin/upgrades/contracts/utils/Address.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * Utility library of inline functions on addresses\n *\n * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/utils/Address.sol\n * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\n * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\n * build/artifacts folder) as well as the vanilla Address implementation from an openzeppelin version.\n */\nlibrary OpenZeppelinUpgradesAddress {\n    /**\n     * Returns whether the target address is a contract\n     * @dev This function will return false if invoked during the constructor of a contract,\n     * as the code is not actually created until after the constructor finishes.\n     * @param account address of the account to check\n     * @return whether the target address is a contract\n     */\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        // XXX Currently there is no better way to check if there is a contract in an address\n        // than to check the size of the code at that address.\n        // See https://ethereum.stackexchange.com/a/14016/36603\n        // for more details about how this works.\n        // TODO Check this again before the Serenity release, because all addresses will be\n        // contracts then.\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n"
    },
    "@openzeppelin/upgrades/contracts/ownership/Ownable.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n *\n * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/ownership/Ownable.sol\n * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\n * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\n * build/artifacts folder) as well as the vanilla Ownable implementation from an openzeppelin version.\n */\ncontract OpenZeppelinUpgradesOwnable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}